# Algorithm
기본 알고리즘에 대한 개념을 설명합니다.

### 정렬 알고리즘 정리
- `Bubble Sort`
  - 버블 정렬이란 처음부터 끝까지 자신과 자신의 다음 데이터를 비교해가면서 큰 값을 맨 뒤로 보내는 방식으로 동작하는 알고리즘이다. 
  - 현재 위치와 다음 위치를 비교하고 현재 값이 크면 스왑한다. 스왑이 되면 현재 자신의 것과 다음 것을 비교해 나간다. 1번의 순환마다 맨 뒤의 값은 고정되고 순환마다 맨 처음부터 다시 시작한다.
  - 시간 복잡도 O(n\^2)
  - 공간 복잡도 O(n)
- `Selection Sort`
  - 선택 정렬은 가장 작은 값을 가지는 데이터를 찾아서 가장 작은 값을 앞에서부터 채워 나가면서 정렬하는 방식의 알고리즘이다. 
  - 1번의 순환마다 맨 앞의 값은 고정되고 순환마다 맨 앞에서부터 1칸씩 뒤로 가면서 순환이 시작된다. 시작점의 값에 관계없이 1번의 순환마다 데이터의 값 중에서 제일 작은 값을 찾고 선두에 배치한다.
  - 시간 복잡도 O(n\^2)
  - 공간 복잡도 O(n)
- `Insertion Sort`
  - 삽입 정렬은 선두에서부터 시작하는 알고리즘으로 다음 데이터와 그 이전 자료를 비교해가며 그 이전 자료들보다 현재의 비교 자료가 더 작을 경우 앞으로 스왑하는 방식으로 계속 동작한다. 맨 앞이나 맨 뒤가 고정되지 않고 순환의 결과 때마다 그 칸 수에서만 정렬이 되고 그것이 확장되어 가는 구조이다. 시작 값은 순환을 할 때마다 맨 앞에서부터 1칸씩 뒤로 가는데 비교 값도 그거에 맞춰 1칸씩 뒤로 간다. 비교 값이 자신의 앞의 데이터들보다 작은 경우 계속 스왑한다.
  - 시간 복잡도 O(n\^2)
  - 공간 복잡도 O(n)
- `Heap Sort`
  - 힙 정렬은 힙을 이용한 정렬 알고리즘이다. 힙 트리를 구성하고 힙에 데이터를 삽입한다. 힙 트리의 느슨한 정렬 상태를 이용하여 하나씩 요소를 힙에서 꺼내고 뒤에서 부터 값을 채워 나가 정렬하는 알고리즘이다. 최소힙일 경우 앞에서부터 채워 나가면 된다.
  - 시간 복잡도 O(nlogn)
  - 공간 복잡도 O(n)
- `Merge Sort`
  - 병합 정렬은 배열을 반으로 쪼개 가면서 하나의 원소를 가진 배열로 만든 이후에 각 배열을 정렬하면서 병합하여 최종 정렬된 배열을 완성하는 알고리즘이다.
  - 분할 정복 알고리즘으로 보통 재귀호출을 통해 구현한다.
  - 시간 복잡도 O(nlogn)
  - 공간 복잡도 O(2n) -> O(n)
- `Quick Sort`
  - 퀵 정렬은 기준이 되는 기준 점(값, 피벗)을 가지고 앞 뒤 배열을 쪼개고 기준 값보다 작은 수를 기준 값 앞으로 기준 값보다 큰 값을 기준 값 뒤로 보내면서 다시 이를 피벗 기준의 쪼개진 두 개의 배열을 계속 순환 호출해가면서 정렬하는 알고리즘이다. 순환 호출 한번 마다 피봇의 위치는 고정된다. 이미 정렬된 배열을 정렬하는 최악의 경우 O(n^\2)의 시간 복잡도를 같게 되는데 `랜덤 피벗`을 설정하여 이를 방지 할 수 있다.
  - 분할 정복 알고리즘으로 보통 재귀호출을 통해 구현한다.
  - 시간 복잡도 O(nlogn) ~ O(n\^2)
  - 공간 복잡도 O(n)

### 탐색 알고리즘 정리
- `순차 탐색`
  - 순차 탐색은 여러 데이터 중에서 원하는 데이터를 찾을 때 데이터가 담겨있는 컨테이너를 앞에서부터 하나씩 하니씩 찾아가는 알고리즘이다.
  - 시간복잡도 O(n)
- `이진 탐색`
  - 이진 탐색은 여러 데이터 중에서 원하는 데이터를 찾을 때 데이터가 담겨있는 컨테이너가 `정렬되어 있을 때` 사용할 수 있는 알고리즘이다.
  - 가운데 값을 탐색하고 탐색하고자 하는 값과 비교하고 같으면 리턴한다. 작은 경우는 중앙 값 기준 왼쪽의 리스트를 입력으로 다시 이진 탐색을 재귀적으로 실행하고 큰 경우는 중앙 값 기준 오른쪽의 리스트를 입력으로 다시 이진 탐색을 재귀적으로 실행하여 탐색한다.
  - 1회성 탐색은 순차 탐색이 좋고 탐색의 회수가 높다면 정렬 이후에 이진 탐색을 하거나 해시나 이진 탐색 트리를 사용하는 것이 좋다.
  - 분할 정복 알고리즘으로 보통 재귀호출을 통해 구현한다.
  - 시간 복잡도 O(nlogn)

### 그래프 알고리즘 정리
- `BFS`
  - 정점들과 같은 레벨에 있는 노드들 (형제 노드들)을 먼저 탐색하는 방식으로 그래프와 그래프의 특이 케이스인 트리 모두에서 사용할 수 있다.
  - 기본적으로 방문이 끝난 정점을 기록하는 `큐`와 방문할 정점을 기록하는 `큐` 2개를 이용하여 구현한다.
  - 시간복잡도 O(V+E)
- `DFS`
  - 정점의 자식들을 먼저 탐색하는 방식으로 그래프와 그래프의 특이 케이스인 트리 모두에서 사용할 수 있다.
  - 기본적으로 방문이 끝난 정점을 기록하는 `큐`와 방문할 정점을 기록하는 `스택` 각각 1개를 이용하여 구현하거나 `재귀 호출`을 통해 구현한다.
  - 시간복잡도 O(V+E)
- `다익스트라 알고리즘`
  - `단일 노드`에서 모든 각 노드들까지의 최단 경로를 탐색하는 알고리즘으로 `양의 가중치만 존재할 때` 사용할 수 있다.
  - 힙을 이용하면 방문 노드를 선택할 때 복잡도를 줄일 수 있다.
  - 알고리즘 수행 과정은 초기화 단계와 경로 탐색 단계로 나뉜다. 
  - 초기화 단게는 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 무한대로 자기 자신 장점까지의 거리는 0으로 하여 저장하고 힙에 첫 정점을 삽입한다.
  - 탐색 단계는 힙에서 정점을 꺼내고 그 정점에 인접한 정점들 각각에 대해, 정점에서 각 정점으로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교하고 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 정점로 가는 거리가 더 짧을 경우, 배열에 해당 정점까지의 거리를 업데이트하고 업데이트된 정점를 힙에 삽입한다. 이를 힙이 비어있을 때까지 반복한다.
  - 정점에서 시작 정점으로부터의 최단 경로가 업데이트될 때 정점을 방문하기 이전에 거쳐야하는 정점을 병기해두면 도착 정점부터 역추적하면 이후 최단 경로 출력을 할 수 있다. 
  - 맨 처음 시작 정점과의 거리를 무한대로 초기화 했기 때문에 모든 노드는 한번 방문하게 되고 방문한 정점은 재방문되지 않는다.
  - 그리디 알고리즘이다.
  - 시간 복잡도 O(ElogE) / O(ElogV)
- `벨먼-포드 알고리즘`
  - `단일 노드`에서 모든 각 노드들까지의 최단 경로를 탐색하는 알고리즘으로 `음의 가중치가 있어도` 사용할 수 있다.
  - 한 노드에서 시작해 한 노드로 끝나는 경로중에 경로의 가중치를 모두 합한 값이 음수가 되는 경로인 음의 사이클이 존재하는 경우에는 사용할 수 없다.
  - 다익스트라 알고리즘에 비해 성능이 떨어지나 음의 가중치가 있을 때에도 사용할 수 있다는 장점이 있다.
  - 알고리즘 수행 과정은 초기화 단계와 경로 탐색 단계 그리고 음의 사이클 체크 단계로 나뉜다.
  - 초기화 단계는 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 무한대로 자기 자신 장점까지의 거리는 0으로 하여 저장한다.
  - 탐색 단계는 시작 정점부터 새롭게 얻어진 각 정점까지의 거리 정보를 통해서 배열을 업데이트하고 엣지의 개수만큼 반복하면서 업데이트 된 정점까지의 거리 정보를 통해 다른 정점들도 업데이트를 할 수 있다면 계속 업데이트한다. 이를 모든 정점에 대해 얻어진 거리 정보들을 통해 업데이트 해야하므로 (모든 정점의 개수 -1)번을 수행한다.
  - 음의 사이클 체크 단계는 각각의 정점에 대한 최소 가중치 배열을 완전히 구한 이후에 실행한다. 다시 한번 엣지의 개수만큼 각 정점들까지의 거리 정보를 업데이트하는데 여기서 변동이 있을 경우 음의 사이클이 생긴 것을 체크할 수 있다.
  - 다익스트라 알고리즘은 현재 시점에서의 최소 경로를 다음 방문지로 선정하기 위해서 Heap을 사용하지만 벨먼-포드는 그런 과정이 없이 순서 없이 모든 정점들의 각 엣지를 V-1번 반복하는 것이 큰 차이이고 복잡도의 차이도 이곳에서 발생한다. 
  - 정점에서 시작 정점으로부터의 최단 경로가 업데이트될 때 정점을 방문하기 이전에 거쳐야하는 정점을 병기해두면 도착 정점부터 역추적하면 이후 최단 경로 출력을 할 수 있다. 
  - 동적 계획 알고리즘이다.
  - 시간 복잡도 O(VE) / O(E^2)
- 플로이드-워샬 알고리즘
  - `모든 노드`에서 모든 각 노드들까지의 최단 경로를 탐색하는 알고리즘으로 `음의 가중치가 있어도` 사용할 수 있다.
  - 한 노드에서 시작해 한 노드로 끝나는 경로중에 경로의 가중치를 모두 합한 값이 음수가 되는 경로인 음의 사이클이 존재하는 경우에는 사용할 수 없다.
  - 벨먼-포드와 다익스트라에 비해 성능이 현격히 떨어지지만 모든 노드에 대한 최단경로를 한번에 구할 수 있다는 장점이 있다.
  - 알고리즘 수행 과정은 초기화 단계와 경로 탐색 단계 그리고 음의 사이클 체크 단계로 나뉜다.
  - 초기화 단게는 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 무한대로 자기 자신 장점까지의 거리는 0으로 하여 저장한다.
  - 탐색 단계는 모든 정점에 대해서 V^3으로 반복하면서 각각의 정점은 값을 찾았을 때 업데이트한다.
  - 시간 복잡도 O(V^3)

### 최소 신장 트리 알고리즘 정리
- 신장 트리는 그래프의 특별한 경우로 사이클을 가지지 않은 연결 그래프인 트리 중에서 모든 노드끼리 연결되어 있는 트리이다. 최소 신장 트리는 스패닝 트리 중에서 엣지들의 가중치의 합이 최소인 스패닝 트리를 칭한다.
- `Kruskal 알고리즘`
  - 모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교하고 사이클을 만들지 않을 경우 정점을 연결하며 최소 신장 트리를 만드는 알고리즘이다.
  - 사이클 생성 여부를 판단할 때 `Union-Find` 알고리즘을 활용하여 각각의 정점이 사이클 생성 여부를 판단한다.
  - Union-Find 알고리즘은 각각의 원소는 처음에는 트리의 독립적인 노드로 존재하다가 이후 Union 과정에서 Union을 수행하는 노드들이 합쳐진다. 이때 어떤 노드를 하나 루트로 선정한다. 이후에 Union 하게되면 추가되는 노드는 루트 노드에 부모 자식 관계로 쭉 이어 붙여서 같은 집합(트리)임을 의미하게 한다. Find는 속한 집합에서 루트 노드를 찾는 과정이다. Union 과정 안에서 Find 과정이 포함되어 있어 합치려는 집합(트리)들의 루트 노드가 같다면 서로서 집합의 개념이 깨지는 것을 의미한다.
  - Union-Find 알고리즘은 `union-by-rank 기법`과 `path-compression 기법`을 통해서 복잡도를 줄인다.
  - union-by-rank 기법은 Union시 두 트리의 높이(rank)가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙이고 같으면 하나의 트리의 높이를 올려서 붙이는 기법이다.
  - path-compression 기법은 find하는 과정에서 만나는 모든 노드들의 부모를 최종 find 이후의 root로 바로 설정하여 이후 find 연산을 간단하게 만드는 기법이다. 
  - 그리디 알고리즘이다.
  - 시간복잡도 O(ElogE)
- `Prim 알고리즘`
  - 임의의 시작 정점을 선택한 후, 정점에 인접한 간선 중 최소 간선으로 연결된 정점을 선택하고, 해당 정점에서 다시 최소 간선으로 연결된 정점을 선택하는 방식으로 최소 신장 트리를 확장해가며 최소 신장 트리를 만드는 알고리즘이다.
  - 처음 모든 간선들을 간선 리스트에 저장하고 시작 정점 부터 얻어진 선택된 간선은 전역 간선 리스트에서 제외해가면서 전역 간선 리스트에 간선이 없을 때까지 간선 선택을 반복한다.
  - 해당 정점들을 통해 얻어진 간선에 연결된 인접 정점이 연결된 노드 집합에 이미 들어 있다면, 스킵하여 사이클을 막을 수 있다.
  - 힙을 이용하면 최소 가중치 엣지를 선택할 때 시간 복잡도를 줄일 수 있다.
  - 간선을 기준으로 하는 것이 아닌 노드를 기준으로 알고리즘을 적용할 경우 프림 알고리즘의 복잡도를 조금 더 개선할 수 있다.
  - 그리디 알고리즘이다.
  - 시간복잡도 O(ElogE) / O(ElogV)

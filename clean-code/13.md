# 13장 동시성

## 구성
1. [동시성이 필요한 이유?](#동시성이-필요한-이유)
2. [난관](#난관)
3. [동시성 방어 원칙](#동시성-방어-원칙)
4. [라이브러리를 이해하라](#라이브러리를-이해하라)
5. [실행 모델을 이해하라](#실행-모델을-이해하라)
6. [동기화하는 메서드 사이에 존재하는 의존성을 이해하라](#동기화하는-메서드-사이에-존재하는-의존성을-이해하라)
7. [동기화하는 부분을 작게 만들어라](#동기화하는-부분을-작게-만들어라)
8. [올바른 종료 코드는 구현하기 어렵다](#올바른-종료-코드는-구현하기-어렵다)
9. [스레드 코드 테스트하기](#스레드-코드-테스트하기)


## 동시성이 필요한 이유?
- 동시성은 결합<sup>Coupling</sup> 을 없애는 전략이다. 즉, 무엇<sup>what</sup>과 언제<sup>when</sup>를 분리하는 전략이다.
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다. 따라서 프로그램의 흐름이 곧 호출 스택이다.
- `서블릿<sup>Servlet</sup>`
  - 웹 어플리케이션의 표준인 서블릿은 웹 혹은 EJB 컨테이너라는 우산 아래서 돌아가는데, 이들 컨테이너는 **동시성을 부분적으로 관리**한다.
  - 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다. 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
- 빠른 응답 시간과 작업 처리량<sup>throughput</sup> 개선이 필요한 시스템에서 단일 스레드를 사용하게 되면 매우 느려진다.

#### 미신과 오해
- 미신과 오해
  - 동시성은 항상 퍼포먼스를 향상시킨다. -> 동시성은 여러 스레드가 프로세서를 공유할 수 있거나 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 좋아진다. ->
  - 동시성을 구현해도 설계는 변하지 않는다. -> 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
  - 웹 또는 EJB 컨테이너를 사용한다면 동시성을 이해할 필요가 없다. -> 실제로 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야한다.
- 사실
  - 동시성은 다소 부하를 유발한다.
  - 동시성은 복잡하다.
  - 일반적으로 동시성 버그는 재현하기 어렵다.
  - 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

## 난관

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

인스턴스 `X` 를 생성하고, `lastIdUsed` 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유할 경우 일어날 수 있는 문제점은 아래와 같다.

1. 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. `lastIdUsed` 는 44가 된다.
2. 한 스레드는 44를 받는다. 다른 스레드는 43을 받는다. `lastIdUsed` 는 44가 된다.
3. 한 스레드는 43을 받는다. 다른 스레드는 43을 받는다. `lastIdUsed` 는 43가 된다.

3번의 경우는 전처리 증가 연산자가 중단이 가능하기 때문에 `원자적 연산`이 아니기 때문에 일어날 수 있다.

## 동시성 방어 원칙

#### 단일 책임 원칙<sup>Single Responsibility Principle, SRP</sup>
동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하여 동시성 관련 코드는 다른 코드와 분리해야 한다.
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
  - 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

#### 따름 정리<sup>Corollary</sup>: 자료 범위를 제한하라
- 객체 하나를 공유한 후 동일 필드를 수정하면 스레드간 간섭으로 예상치 못한 결과가 나타난다.
- 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역<sup>critical section</sup>을 `synchronized` 키워드로 보호하라고 권장한다.
- 임계영역이 많으면 많을 수록 다음의 가능성이 커진다.
  1. 보호할 임계영역을 빼먹는다.
  2. 모든 임계영역을 올바로 보호(DRY)했는지 확인하느라 노력과 수고를 반복한다.
  3. 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.

#### 따름 정리: 자료 사본을 사용하라
- 각 스레드가 객체를 복사해 사용한 후 해당 사본에서 결과를 가져와 공유 자료를 줄이는 방식이 있다.
- 사본 생성 비용과 가비지 컬렉션에 드는 비용과 동기화로 인한 복잡성과 내부 락 비용을 비교해 적절히 선택하라.

#### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드로 구현하라. 다른 스레드와 자료를 공유하지 않고 모든 정보를 비공유 출처에서 가져와 로컬 변수로 저장한다.
- `HttpServlet` 클래스에서 파생한 클래스는 모든 정보를 `doGet`과 `doPost` 매개변수로 받기 때문에 각 서블릿이 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.

## 라이브러리를 이해하라
자바5 이상에선 아래의 사항들을 고려해보라.
  - 스레드 환경에 안전한 컬렉션 사용
  - 서로 무관한 작업을 수행할 때는 `executor` 프레임워크를 사용
  - 가능하다면 스레드가 차단<sup>blocking</sup> 되지 않는 방법을 사용
  - 일부 클래스 라이브러리는 스레드에 안전하지 못함을 인지

#### 스레드 환경에 안전한 컬렉션
`java.util.concurrent` 패키지가 제공하는 클래스는 멀티 스레드 환경에서 사용해도 안전하며 성능도 좋다. `ConcurrentHashMap`의 경우에는 대부분의 상황에서 `HashMap`보다 더 좋은 퍼포먼스를 제공한다.

## 실행 모델을 이해하라

|---|---|
|---|---|
| 한정된 자원 | 다중 스레드 환경에서 사용하는 한정된 자원(커넥션 풀, 버퍼 길이 등) |
| 상호 배제 |한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우|
| 기아 | 오랫동안 혹은 영원히 자원을 기다리는 상태 |
| 데드락 | 여러 스레드가 서로 끝나기를 기다림 |
| 라이브락 | 락을 거는 단계에서 각 스레드가 서로를 방해 |

#### 생산자-소비자<sup>Producer-Consumer</sup>
- 하나 이상의 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
- 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
- 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채운다. 즉, 빈 공간이 있을때 까지 기다리며 반대로 소비자 스레드는 정보가 채워질 때까지 기다린다.
- 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다. -> 생산자가 데이너 넣고 시그널 전송 동시에 소비자가 데이터 읽고 시그널 전송 => 서로 상대가 소비하기까지 무한히 기다리게된다.

#### 읽기-쓰기<sup>Readers-Writers</sup>

처리량<sup>throughput</sup>을 강조해 읽기 스레드가 상대적인 우선권을 가지게 되면 쓰기 스레드가 기아 상태에 빠지며 공유 자원은 정체된 정보로 가득차게 된다. 반대로 쓰기 스레드가 우선권을 가지면 처리량이 줄어들게 된다.

#### 식사하는 철학자들<sup>Dining Philosophers</sup>

[정의 링크](https://ko.wikipedia.org/wiki/식사하는_철학자들_문제)

**권장사항**: 위에서 설명한 기본 알고리즘과 각 해법을 이해하라.

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인해야한다.
- `공유 객체 하나에는 메서드 하나만 사용하라.`
- 추가적인 해결 방법
  - 클라이언트에서 잠금
     - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠금. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  - 서버에서 잠금
     - 트랜잭션을 서버에 구현하고 클라는 호출만 한다.
  - 연결<sup>Adapted</sup> 서버
     - 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.(like 서드 파티 라이브러리)

## 동기화하는 부분을 작게 만들어라
- `synchronized` 키워드를 사용하면 락이 설정된다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다. 하지만 임계영역은 반드시 보호해야한다. 따라서 코드를 짤 때에는 임계영역 수를 최대한 줄여야 한다.

## 올바른 종료 코드는 구현하기 어렵다
- `종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라.`
- 가장 흔히 발생하는 문제가 `데드락`이다. 
  - 데드락에 걸린 자식 스레드의 수행이 끝나길 기다리는 부모 스레드의 경우가 옳다.
  - 자식은 데드락에 걸려 멈춰 있고 부모는 이를 끝없이 기다리게 된다.

## 스레드 코드 테스트하기
스레드는 코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하지는 않는다.

#### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드 코드는 때때로 `말이 안 되는` 오류를 일으킨다.
  - 스레드 코드에 잠입한 버그는 수천, 수백만 번에 한 번씩 드러나기도 한다.
  - 실패를 재현하기가 매우 어렵다.
- 시스템 실패를 `일회성`이라 치부하지 마라.

#### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다.

#### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

다중 스레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라.

- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

#### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다. 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.

#### 프로세서 수보다 많은 스레드를 돌려보라

시스템이 스레드를 [스와핑](https://jhnyang.tistory.com/103)<sup>swapping</sup> 할 때도 문제가 발생한다. 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.

#### 다른 플랫폼에서 돌려보라
다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다. 자바 스레드 모델은 선점형 스레드 스케줄링을 보장하지 않는다.

#### 코드에 보조 코드<sup>instrument</sup>를 넣어 돌려라. 강제로 실패를 일으키게 해보라
스레드 관련 문제는 수많은 실행 경로중 얼마 안되는 확률로 발생하기 때문에 드물게 발생하며 재현하기 어렵다.

#### 직접 구현하기 : 실행 경로를 조작해 스레드 문제가 발생할 확률을 높이는 보조 코드 작성 방법 1

```java
public synchronized String nextUrlOrNull() {
  if(hasNext()) {
    String url = urlGenerator.next();
    Thread.yield(); // inserted for testing.
    updateHasNext();
    return url;
  }
  return null;
}
```

코드에 직접 `yield` 등을 삽입하면 코드가 실행되는 경로가 바뀐다. 따라서 이전에 실패하지 않았던 코드가 실패할 가능성을 열어준다. **코드가 실패한다면 `yield`를 추가했기 때문이 아니라 원래 잘못된 코드인데 증거가 없었을 뿐이다**.

이 방법에는 몇가지 문제가 있다.

- 테스트할 부분을 직접 찾아야 한다.
- 어디에 어느 메서드를 호출해야 할지 알기 어렵다.
- 이와 같은 코드를 제품에 포함해 배포하면 성능이 떨어진다.
- 무작위적이기 때문에 문제가 발생한다는 보장을 얻을 수 없다.

배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요하다. 스레드를 전혀 모르는 POJO와 스레드를 제어하는 클래스로 프로그램을 분할하면 보조 코드를 추가할 위치를 찾기가 쉬워진다.

#### 자동화 : 실행 경로를 조작해 스레드 문제가 발생할 확률을 높이는 보조 코드 작성 방법 2

보조 코드를 자동으로 추가하려면 AOP 같은 도구를 사용한다.

```java
public class ThreadJigglePoint {
  public static void jiggle() { }
}

public synchronized String nextUrlOrNull() {
  if(hasNext()) {
    ThreadJiglePoint.jiggle();
    String url = urlGenerator.next();
    ThreadJiglePoint.jiggle();
    updateHasNext();
    ThreadJiglePoint.jiggle();
    return url;
  }
  return null;
}
```

위와 같이 구현한 후 간단한 `Aspect`를 이용해 `아무 것도 안하기`, `sleep`, `yield`등을 무작위로 선택하게 할 수 있다.
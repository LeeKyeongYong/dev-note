# 17장 냄새와 휴리스틱

## 구성
1. [주석](#주석)
2. [환경](#환경)
3. [함수](#함수)
4. [일반](#일반)
5. [자바](#자바)
6. [이름](#이름)
7. [테스트](#테스트)


## 주석

#### C1 : 부적절한 정보
- 불필요한 주석은 코드를 번잡하게 만든다.
- 작성자, 최종 수정일, SPR 번호 정도만 주석으로 넣는다.

#### C2 : 쓸모 없는 정보
쓸모 없어질 주석은 아예 달지 않는 편이 좋다.

#### C3 : 중복된 주석
코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다.

#### C4 : 성의없는 주석
주석을 달 것이라면 시간을 들여 최대한 멋지게 작성한다.

#### C5 : 주석처리된 코드
주석 처리된 코드는 흉물 그 자체이다.

## 환경

#### E1 : 여러 단계로 빌드해야 한다
빌드는 간단히 한 단계로 끝나야 한다.

#### E2 : 여러 단계로 테스트해야 한다
모든 단위 테스트는 한 명령으로 돌려야 한다.

## 함수

#### F1 : 너무 많은 인수
함수에서 인수의 개수는 아예 없는 것이 가장 좋고 최대한 작을 수록 좋다.

#### F2 : 출력 인수
- 출력 인수는 직관을 무시한다.
- 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

#### F3 : 플래그 인수
boolean 인수는 함수가 여러 기능을 숭핸하다는 명백한 증거이다.

#### F4 : 죽은 함수
아무도 호출하지 않는 함수는 삭제한다.

## 일반

#### G1 : 한 소스 파일에 여러 언어를 사용한다
소스 파일 하나에 하나의 언어만 사용하긴 힘들지만, 최대한 적은 언어 수와 범위로 작성한다.

#### G2 : 다양한 동작을 구현하지 않는다

#### G3 : 경계를 올바로 처리하지 않는다
- 경계 조건을 꼼꼼히 처리해야한다.
- 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 코드를 작성하라.

#### G4 : 안전 절차 무시
- 모든 테스트 케이스를 통과 시킨다.
- 컴파일러의 경고 일부도 놓치지 않는다.

#### G5 : 중복
- 코드에서 중복을 발견하면 추상화할 기회로 간주하라.
- 가장 뻔한 중복의 유형은 똑같은 코드의 반복이다.
  - 간단한 함수로 처리한다.
- 좀 더 미묘한 중복의 유형은 일련의 분기문으로 똑같은 조건을 거듭 확인하는 것이다.
  - `다형성`으로 처리한다.
- 더더욱 미묘한 중복의 유형은 알고리즘은 유사하나 코드가 서로 다운 중복이다.
  - `템플릿 메소드 패턴`이나 `STRATEGY 패턴`으로 제거한다.

#### G6 : 추상화 수준이 올바르지 못하다
- 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
- 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.
```java
pulbic interface Stack{
    Object pop() throws EmptyException;
    double percentFull();
    class EmptyException extends Exception {}
}
```
위 클래스의 percentFull() 메소드는 Stack 인터페이스의 추상화 수준을 넘었다. BoundedStack과 같은 인터페이스에 어울린다.

#### G7 : 기초 클래스가 파생 클래스에 의존한다
- 기초 클래스와 파생 클로스로 나누면 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장해준다.
- 기초 클래스는 파생 클래스를 아예 몰라야한다.

#### G8 : 과도한 정보
- 정보를 제한해 `결합도`를 낮춰라.
- 잘 정의된 모듈은 인터페이스의 크기가 아주 작다.
- 클래스가 제공하는 메소드 수가 작을 수록 좋다.
- 함수가 아는 변수의 수가 작을 수록 좋다.
- 클래스에 있는 인스턴스 변수의 수도 작을 수록 좋다.

#### G9 : 죽은 코드
실행되지 않는 코드는 제거하라.

#### G10 : 수직 분리
변수와 함수는 사용되는 위치에 가깝게 정의하라.

#### G11 : 일관성 부족
- 어떤 개념을 특정 방식으로 사용하고 구현했다면 유사한 개념도 같은 방식으로 한다.

#### G12 : 잡동사니
비어 있는 기본 생성자, 사용하지 않는 변수, 호출되지 않는 함수같은 잡동사니를 없애라.

#### G13 : 인위적 결합
- 서로 무관한 개념을 인위적으로 결합하지 않는다.
  - enum은 특정 클래스에 속할 이유가 없다.
  - 범용 static 함수도 특정 클래스에 속할 이유가 없다.

#### G14 : 기능 욕심
- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
- `기능 욕심`은 한 클래스의 내부를 다른 클래스에 노출하므로 제거하는 편히 좋다.

#### G15 : 선택자 인수
- `선택자 인수`는 목적을 기억하기 어려울 뿐만 아니라 여러 하수를 하나로 조합한다.
```java
public int calculateWeeklyPay(boolean overtime){
    int tenthRate =  getTenthRate();
    int tenthsWorked = getTenthsWorked();
    int straightTime = Math.min(400, tenthWorked);
    int straightPay = straightTime * tenthRate;
    double overtimeRate = overtion ? 1.5 : 1.0 * tenthRate;
    int overtionePay = (int)Math.round(overTime*overtimeRate);
    return straightPay * overtimePay;
}
```
위 코드는 초과근무 수당을 1.5배 지급하면 true이고 아니면 false이다. 혼란스럽다.
```java
public int straightPay(){
    return getTenthsWorked() * getTenthRate();
}
```

```java
public int overTimePay(){
    int overTimeTenths =  Math.max(0, getTenthsWorked() - 400);
    int overTimePay = overTimeBonus(overTimeTenths);
    return straightPay() + overTimePay;
}
```

```java
private int overTimeBonux(int overTimeTenths){
    double bonus = 0.5 * getTenthRate() * overTimeTenths;
    return (int) Math.round(bonus);
}
```

#### G16 : 모호한 의도
코드를 짤 때는 의도를 최대한 분명히 밝힌다.

#### G17 : 잘못 지운 책임
코드를 배치하는 위치는 매우 중요하다.

#### G18 : 부적절한 static 변수
특정 객체와 관련이 없으면서 모든 정보를 인수에서 가져와도 static 함수가 좋지 않을 수 있다.
```java
HourlyPayCalculator.calculatePay(employee, overtimeRate);
```
상기 코드에서 계산하는 방식이 여러 가지가 일 수 있다면 `calculatePay`는 리펙토링 되어야한다.

#### G19 : 서술적 변수
프로그램의 가독성을 높이는 가장 좋은 방법은 `서술적인 변수 이름`을 사용하는 것이다.

```java
headers.put(match.group(1).toLowerCase(), match.group(2));
```
어떤 코드인지 알기 힘들다.

```java
String key = match.group(1);
String value = match.group(2);
headers.put(key.toLowerCase(), value);
```
key와 value를 추가하므로써 가독성이 높아졌다.

#### G20 : 이름과 기능이 일치하는 함수

#### G21 : 알고리즘을 이해하라
구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라. 테스트 케이스를 통과했다는 사실만으로 부족하다.

#### G22 : 논리적 의존성은 물리적으로 드러내라
- 모듈끼리 의존한다면 물리적인 의존성도 표현되어야한다.
- 의존하는 모든 정보를 명시적으로 요청하는 방식이 좋다.
  - 상수로 선언된 `PAGE_SIZE` 보다 `getMaxPageSize()` 함수를 사용하는 것이 물리적 의존성을 더 표현한다.

#### G23 : If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

#### G24 : 표준 표기법을 따르라
- 팀은 업계 표준에 기반한 표준을 따라야한다.
- 팀원은 팀이 정한 표준을 따라야한다.

#### G25 : 매직 숫자는 명명된 상수로 교체하라
- 의미가 불분명한 토큰은 상수로 바꿔라.
  - 864000 이라는 매직숫자보다 SECOND_PER_DAY라는 상수가 좋다.
```java
assertEquals(7777, Employee.find("John Doe").employeeNumber());
```
위 코드는 7777과 "John Doe"가 무슨 의미인지 알기 어렵다.
```java
int HOURLY_EMPLOYED_ID = 7777;
String HOURLY_EMPLOYEE_NAME = "John Doe";
assertEquals(HOURLY_EMPLOYED_ID, Employee.find(HOURLY_EMPLOYEE_NAME).employeeNumber());
```
7777과 "John Doe"가 무슨 의미인지를 표현해준다.

#### G26 : 정확하라

#### G27 : 관례보다 구조를 사용하라
- 규칙보다 관례를 사용하여 강제하라.
- 분기문으로 구현하면 강제하기 어렵지만, 파생 클래스로 구현하면 모두 구현해야하므로 강제할 수 있다.

#### G28 : 조건을 캡슐화하라
조건의 의도를 분명히 밝히는 함수를 표현하라.
```java
if (shouldBeDeleted(timer));
```
어떤 의미인지 알기 어렵다.

```java
if (timer.hasExpired() && !timer.isRecurrent())
```
조건이 캡슐화되어 있어 알 수 있다.

#### G29 : 부정 조건은 피하라
부정 조건은 긍정 조건보다 이해하기 어렵다.

#### G30 : 함수는 한 가지만 해야 한다

#### G31 : 숨겨진 시간적인 결합
시간적인 결합을 숨겨서는 안된다.

#### G32 : 일관성을 유지하라
구조에 일관성이 없어 보이면 남들이 맘대로 바꿀 수 있다.

#### G33 : 경계 조건을 캡슐화하라
경계 조건은 별도로 처리한다.
```java
if (level + 1 < tags.length)
{
    parts = new Parse(body, tags, level + 1, offset + endTag);
    body = null;
}
```

```java
int nextLevel = leve + 1;
if (nextLevel < tags.length)
{
    parts = new Parse(body, tags, nextLevel, offset + endTag);
    body = null;
}
```

#### G34 : 함수는 초상화 수준을 한 단계만 내려가야 한다
- 함수 내 모든 문장은 추상화 수준이 동일해야한다.
- 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야한다.

#### G35 : 설정 정보는 최상위 단계에 둬라
추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수는 저차원 함수에 숨기지 않는다.

#### G36 : 추이적 탐색을 피하라
한 모듈은 주변 모듈을 모를수록 좋다.

## 자바

#### J1 : 긴 import 목록을 피하고 와일드카드를 사용하라
- 해당 패키지에서 복수의 클래스를 사용할 경우 `import package.*`가 명시적인 import 문 보다 좋다.
- 와일드 카드 import는 모듈 간의 결합성을 낮쳐준다.

#### J2 : 상수는 상속하지 않는다

#### J3 : 상수 대 Enum
`public static final int`보다 `enum`을 사용하라.

## 이름

#### N1 : 서술적인 이름을 사용하라
서술적인 이름은 가독성을 높여준다.

#### N2 : 적절한 추상화 수준에서 이름을 선택하라
구현은 드러나지 안되 작업 대상 클래스나 함수가 위치하는 추상화 수준은 반영하는 이름을 선택하라.

#### N3 : 가능하다면 표준 명명법을 사용하라

#### N4 : 명확한 이름

#### N5 : 긴 범위는 긴 이름을 사용하라
이름 길이는 범위 길이에 비례해야한다

#### N6 : 인코딩을 피하라

#### N7 : 이름으로 부수 효과를 설명하라
함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용한다.

## 테스트

#### T1 : 불충분한 테스트
테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트 해야한다.

#### T2 : 커버리지 도구를 사용하라
커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기 쉬워진다.

#### T3 : 사소한 테스트를 건너뛰지 마라

#### T4 : 무시한 테스트는 모호함을 뜻한다

#### T5 : 경계 조건을 테스트하라

#### T6 : 버그 주변은 철저히 테스트하라
버그는 서로 모이는 경향이 있다. 버그를 발견했다면 그 주변을 철저히 테스트하라.

#### T7 : 실패 패턴을 살펴라
테스트 케이스가 실패하는 패턴으로 코드의 문제를 진달할 수도 있다.

#### T8 : 테스트 커버리지 패턴을 살펴라
통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인을 알 수 있다.

#### T9 : 테스트 빨라야 한다
느린 테스트 케이스는 실행하지 않게 된다.
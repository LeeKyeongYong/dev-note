# STL
C/C++에서 자료구조 사용을 편하게 만들어주는 STL 라이브러리에 대한 활용법을 설명합니다.

### STL
- STL은 C/C++을 지원하는 표준 템플릿 라이브러리이다.
- 많이 사용하는 sequence container로는 vector, list, stack, queue, deque가 있다.
- 많이 사용하는 associated container로는 set, map이 있다.
- list보다 vector가 일반적으로 성능이 더 좋기 때문에 list는 본 문서에서는 따로 설명하지 않을 것이다.

### STL과 iterator 클래스
- iterator는 모든 STL container에 대해서 일관성 있는 인터페이스를 제공하는 클래스이다.
- 각각의 container마다 iterator를 할당해줘서 사용할 수 있다. 포인터 변수와 같이 작동을 한다. (Ex. \*iter)
- 반복자는 다양한 종류가 있다. STL의 모든 컨테이너는 양방향 반복자 이상을 제공한다.
- 입력 반복자(input iterator): 현 위치의 원소를 한 번만 읽을 수 있는 반복자(istream)
- 출력 반복자(output iterator): 현 위치의 원소를 한 번만 쓸 수 있는 반복자(ostream)
- 순방향 반복자(forward iterator): 입력, 출력 반복자 기능에 순방향으로 이동(++)이 가능한 재할당될 수 있는 반복자
- 양방향 반복자(bidirectional iterator): 순방향 반복자 기능에 역방향으로 이동(\--)이 가능한 반복자(list, set, map)
- 임의 접근 반복자(random access iterator): 양방향 반복자 기능에 +, -, +=, -=, \[\] 연산이 가능한 반복자(vector, deque)

###  STL 컨테이너 종류

##### vector
- 동적 배열이므로 배열의 크기를 변경할 수 있다.
- 임의 접근이 가능하며, 뒤에서의 삽입이 빠르다.
- 삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1) 보장

##### list
- 연결 리스트이므로 데이터를 순차적으로 접근하고 관리할 때 유용하다.
- 위치에 상관없이 삽입과 삭제가 빠르다.
- 삽입, 삭제 O(1), 탐색, 임의 원소 접근 O(n) 보장

##### deque
- 앞, 뒤에서 삽입 삭제가 가능한 큐이다.
- 임의 접근이 가능하며 앞과 뒤에서의 삽입이 빠르다.
- 삽입, 삭제, 탐색 O(1), 임의 원소 접근 O(n) 보장

##### map
- 특정 키(key)로 데이터를 접근하고 관리할 수 있다.
- 키로 값에 접근하며 삽입과 삭제가 빠르다.
- 삽입, 삭제, 탐색 모두 O(log n) 보장

##### set
- 원소들을 순서대로 관리하며 소속 검사와 삽입, 삭제가 빠르다.
- 중복된 원소를 허용하지 않는다. (map과 set의 차이점, set은 값이 곧 키가 됩니다.)
- 삽입, 삭제, 탐색 모두 O(log n) 보장

##### stack
- top에서만 삽입과 삭제가 가능하다.
- LIFO(Last In First Out) 방식으로 데이터를 삽입, 삭제한다.
- 삽입, 삭제 O(1) 보장

##### queue
- 삽입은 뒤쪽에서, 삭제는 앞쪽에서 수행한다.
- FIFO(First In First Out) 방식으로 데이터를 삽입, 삭제한다.
- 삽입, 삭제 O(1) 보장

###  algorithm
- #include <algorithm>을 하게 되면 알고리즘과 관련된 많은 함수를 사용할 수 있다.
- 입력 파라미터는 iterator 형태로 넘긴다.
- sort(p, q): 위치 p<= && <q인 원소들을 오름차순 정렬한다.
- sort(p, q, compare): 사용자가 정의한 compare 함수를 통해 비교하여 p<= && <q 원소들을 정렬한다.
- reverse(p, q): 위치 p<= && <q인 원소들을 역순으로 배치한다.
- min_element(p, q): 위치 p<= && <q인 원소들을 중에서 최소값을 찾는다.
- max_element(p, q): 위치 p<= && <q인 원소들을 중에서 최대값을 찾는다.
- find(p, q, e): 위치 p<= && <q인 원소들을 중에서 e를 찾는다.
- lower_bound(p, q, val): 위치 p<= && <q인 원소들을 중에서 val 값보다 작은 가장 작은 위치를 리턴합니다. 오름차순 정렬일 경우 사용 가능하며 정렬을 깨드리지 않고 삽입하려 할 때 유용하다.
- upper_bound(p, q, val): 위치 p<= && <q인 원소들을 중에서 val 값을 초과하는 가장 작은 위치를 리턴한다. 오름차순 정렬일 경우 사용 가능하며 정렬을 깨드리지 않고 삽입하려 할 때 유용하다.

### pair 클래스
- <utility> 헤더에 존재하는 클래스로 STL에서 쌍을 표현할 때 사용하는 구조체이다.
- pair의 첫번째 인자를 first라고 하고 두번째 인자를 second라고 하는데 pair를 하나의 타입으로 보고 컨테이너에 대입할 수 있다.
- make_pair(변수1, 변수2)로 변수가 들어간 pair를 만들 수 있고 이를 STL 컨테이너 안에 대입하여 사용할 수 있다.

### vector
- 벡터는 리스트 자료구조 계열의 컨테이너이다. 벡터는 동적으로 크기 확장이 가능하고 복사 시에 복사 생성자가 자동으로 호출되고 소멸자도 자동으로 호출되는 컨테이너이다.
- 벡터는 랜덤 접근 컨테이너이다. 리스트는 순차적으로 접근을 하기 때문에 방문에서 성능이 느리다. 벡터는 삽입과 삭제에서 약점이 있지만 보통의 경우 Array의 특성 때문에 caching와 page fault의 측면에서 더 좋은 성능을 보인다.
- 생성 함수
  - vector<자료형> 컨테이너명
  - vector<자료형> 컨테이너명(num): 사이즈가 num인 vector 생성한다.
  - vector<자료형> 컨테이너명(num, e): 사이즈가 num이고 원소가 e로 초기화된 vector 생성한다.
- 참조 관련 함수
  - V.begin(): 첫번째 원소를 참조하는 iterator 리턴한다.
  - V.end(): 마지막 원소를 참조하는 iterator 리턴한다.
  - V.rbegin(): 역순으로, 마지막 원소의 다음을 참조하는 iterator 리턴한다.
  - V.rend(): 역순으로, 첫번째 원소를 참조하는 iterator 리턴한다.
- 삽입 삭제 관련 함수
  - V.push_back(e): 원소 e를 제일 마지막에 삽입한다. == V.insert((V.end(),e))
  - V.insert(p, e): 위치 p 앞에 원소 e를 삽입한다. <- list일 때 유리한 함수
  - V.pop_back(): 제일 뒤 원소를 삭제한다. == V.erase((V.end())
  - V.erase(p): 위치 p에 있는 원소를 삭제하고 뒤 원소들을 이동한다. <- list일 때 유리한 함수
  - V.erase(p, q): 위치 p<= && <q에 있는 원소를 삭제하고 뒤 원소들을 이동한다. <- list일 때 유리한 함수
  - V.swap(V2): V와 V2를 바꾼다.
  - V.clear(): 모든 원소를 삭제한다.
- 탐색 함수
  - V.front(): 첫번째 원소에 접근한다. == V[0]
  - V.back(): 마지막 원소에 접근한다.
  - V.at(idx), V[idx]: idx번째 원소에 접근한다.
- 기타 함수
  - V.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.
  - V.size(): 원소의 개수를 리턴한다.
  - V.assign(num, e): 원소의 개수 num만큼 원소 e를 채운다.
  - V.reserve(n): n개의 크기의 저장공간 확보한다.

### 스택(Stack), 큐(Queue), 우선순위 큐(priority_queue)
- STL 스택, 큐, 우선순위 큐는 자료구조와 같은 구조의 컨테이너이다.
- 스택, 큐, 우선순위 큐는 기본 형태가 비슷하여 컨테이너의 함수들이 유사하다.
- 우선순위 큐는 STL에선 디폴트 옵션으로 가장 큰 값이 위로 가는 max heap이 생성된다. 추가적인 compare 함수는 넣어주면 다르게 정의가 가능하다.
- 우선순위 큐는 힙이라는 자료구조를 정의해야 구현이 편하기 때문에 STL에서 이용하는 것이 좋다.
- 3가지 컨테이너 모두 컨테이너에 대한 접근을 제한하므로 반복자를 리턴하여 사용하지 않는다.
- stack 함수
  - stack<자료형> 컨테이너 명
  - S.top(): top 원소에 접근한다.
  - S.push (e): 원소 e를 삽입한다.
  - S.pop(): 자료구조에 맞게 원소를 삭제한다.
  - S.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.
  - S.swap(S2): 컨테이너 S와 컨테이너 S2를 바꾼다.
  - S.size(): 원소의 개수를 리턴한다.
- queue 함수
  - queue<자료형> 컨테이너 명
  - Q.front(): front 원소에 접근한다.
  - Q.back (): back 원소 에 접근한다.
  - Q.push (e): 원소 e를 삽입한다.
  - Q.pop (): 자료구조에 맞게 원소를 삭제한다.
  - Q.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.
  - Q.swap(S2): 컨테이너 S와 컨테이너 S2를 바꾼다.
  - Q.size(): 원소의 개수를 리턴한다.
- priority_queue 함수
  - priority_queue <자료형> 컨테이너 명
  - priority_queue <자료형, 컨테이너 종류<자료형>, 비교함수> 컨테이너 명: 해당 비교 함수에 맞춰서 힙의 모양을 결정한 컨테이너를 생성한다.
  - PQ.top(): top 원소에 접근한다.
  - PQ.push (e): operator<의 요소 우선 순위에 따라 priority_queue에 원소 e를 삽입한다.
  - PQ.pop (): 자료구조에 맞게 원소를 삭제한다.
  - PQ.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.
  - PQ.swap(PQ2): 컨테이너 PQ와 컨테이너 PQ2를 바꾼다.
  - PQ.size(): 원소의 개수를 리턴한다.

### Map
- 맵는 트리 계열의 컨테이너이다.
- (Key, Value)로 구성된 entry들을 쌍으로 저장한다. key는 중복이 될 수 없고 value를 가리키고 value는 저장할 자료이다.
- 맵은 내부가 Red Black Tree로 구현되어 있어 삽입과 삭제 시에 내부에서 자동 정렬된다. 정렬 과정을 피하고 삽입과 삭제 그리고 검색만을 원할 때는 stdext namespace의 hash_map 컨테이너를 사용하면 된다. 그러나 해싱의 특성 때문에 자료가 적을 때는 map이 압도적으로 성능이 좋다. 또한 맵은 반복자를 이용하여 데이터를 순회할 때 key에 따라 정렬된 상태로 순회한다.
- 맵은 디폴트 옵션으로 key를 대상으로 하여 오름차순으로 정렬한다. 다른 정렬을 원할 경우 다른 정렬 방법을 제공해야한다.
- 생성 함수
  - map<키의 자료형, 값의 자료형> 컨테이너명
  - map<키의 자료형, 값의 자료형, 비교 함수> 컨테이너명: 비교 함수로 정렬 기준을 삼은 map을 생성한다.
- 참조 관련 함수
  - M.begin(): 정렬된 맵에서 첫번째 원소를 참조하는 iterator 리턴한다.
  - M.end(): 정렬된 맵에서 마지막 원소의 다음을 참조하는 iterator 리턴한다.
  - M.rbegin(): 역순으로, 정렬된 맵에서 마지막 원소의 다음을 참조하는 iterator 리턴한다.
  - M.rend(): 역순으로, 정렬된 맵에서 첫번째 원소를 참조하는 iterator 리턴한다.
- 삽입 삭제 관련 함수
  - M.insert(make_pair(k,v)): 키가 k이고 값이 v인 요소를 삽입한다.
  - M[k] = v: 키가 k이고 값이 v인 요소를 삽입한다.
  - M.erase(k): 키가 k인 요소를 삭제한다.
  - M.swap(M2): MV와 M2를 바꾼다.
  - M.clear(): 모든 원소를 삭제한다.
- 탐색 함수
  - M.find(k): key가 k인 요소를 참조하는 iterator를 리턴한다.
  - M.at(key), M[key]: key와 관련된 원소에 접근한다.
- 기타 함수
  - M.size(): 원소의 개수를 리턴한다.
  - M.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.

### Set
- 셋은 트리 계열의 컨테이너이다.
- Key가 노드로 저장된다. key는 중복이 될 수 없다. 그러나 key 자체를 pair로 하여 삽입할 수 있다. 정렬이 불가능하고 중복 값 처리가 되는 벡터라고 할 수 있다.
- 셋은 맵과 마찬가지로 삽입 삭제 시에 내부에서 자동 정렬된다. 정렬 과정을 피하고 삽입과 삭제 그리고 검색만을 원할 때는 stdext namespace의 hash_set 컨테이너를 사용하면 된다. 그러나 해싱의 특성 때문에 자료가 적을 때는 set이 압도적으로 성능이 좋다. 또한 셋은 반복자를 이용하여 데이터를 순회할 때 key에 따라 정렬된 상태로 순회한다.
- 맵은 디폴트 옵션으로 key를 대상으로 하여 오름차순으로 정렬한다. 다른 정렬을 원할 경우 다른 정렬 방법을 제공해야한다.
- 생성 함수
  - set<키의 자료형> 컨테이너명
  - set<키의 자료형, 비교함수> 컨테이너명: 비교 함수로 정렬 기준을 삼은 set을 생성한다.
- 참조 관련 함수
  - S.begin(): 정렬된 셋에서 첫번째 원소를 참조하는 iterator 리턴한다.
  - S.end(): 정렬된 셋에서 마지막 원소의 다음을 참조하는 iterator 리턴한다.
  - S.rbegin(): 역순으로, 정렬된 셋에서 마지막 원소의 다음을 참조하는 iterator 리턴한다.
  - S.rend(): 역순으로, 정렬된 셋에서 첫번째 원소를 참조하는 iterator 리턴한다.
- 삽입 삭제 관련 함수
  - S.insert(k): 키가 k인 요소를 삽입한다.
  - S.erase(k): 키가 k인 요소를 삭제한다.
  - S.swap(S2): S와 S2를 바꾼다.
  - S.clear(): 모든 원소를 삭제한다.
- 탐색 함수
  - S.find(k): key가 k인 요소를 참조하는 iterator를 리턴한다.
- 기타 함수
  - S.size(): 원소의 개수를 리턴한다.
  - S.empty(): 비어 있으면 True를 비어 있지 않으면 False를 리턴한다.

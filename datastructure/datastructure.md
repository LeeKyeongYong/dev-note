# Datastructure
기본 자료구조에 대한 일반적인 개념을 서술합니다.

###  배열(Array)
- 배열은 데이터를 1열로 나열한 데이터 구조로 메모리 영역에 순서대로 저장된다. 데이터에 접근하기는 쉽지만 추가나 삭제에 시간이 걸린다.
- Index를 통해서 접근할 수 있다.
- 중간 데이터를 추가하는 경우 더 큰 배열을 확보하고 추가하고자 하는 배열의 Index의 뒷 부분부터 하나씩 밀어야 한다.
- 중간 데이터를 삭제하는 경우 삭제하고자 하는 배열의 Index의 뒷 부분부터 하나씩 댕겨야 한다.
- 접근(O(1))은 빠르나 추가(O(n))와 삭제(O(n))는 느린 자료구조이다.

### 리스트(List)
- 리스트는 데이터를 일직선으로 나열한 데이터 구조로 메모리 영역에 순차적으로 저장되어 있지 않아도 된다. 데이터를 추가하거나 삭제하는 것은 쉬우나 접근하는 것은 시간이 걸린다.
- 데이터 필드와 링크(포인터) 필드를 합쳐서 노드라고 하는 기본 단위로 저장한다.
- 각 노드는 데이터 값과 포인터가 있어 포인터를 통해 다음 데이터의 메모리 위치를 가리킨다.
- 한 쪽에서부터 순서대로 따라가서 순차 접근해야 목적지에 접근할 수 있다.
- 중간 노드를 추가하는 경우 앞/뒤 노드들의 포인터가 가리키는 메모리 위치를 삽입하려는 노드로 변경하고 중간 노드를 삽입한다.
- 중간 노드를 삭제하는 경우 앞/뒤 노드들의 포인터가 가리키는 메모리 위치를 삭제 이후의 노드로 변경하고 중간 노드를 삭제한다.
- 접근(O(n))은 느리나 추가와 삭제는 빠른 자료구조이다.
- 단일 연결 리스트와 이중 연결 리스트가 있는데 단일 연결 리스트는 하나의 노드에서 후속 노드만 가리킬 수 있는 자료구조이고 이중 연결 리스트는 하나의 노드에서 선행 노드와 후속 노드를 모두 가리킬 수 있는 자료구조이다.

### 스택(Stack)
- 스택은 데이터를 1열로 나열하고 임의의 객체들을 삽입한 순서대로 저장하고 나중에 들어간 데이터를 삭제하는 자료구조이다.
- 데이터가 들어오는 곳과 나가는 곳이 `TOP`으로 같다.
- 후입선출 구조의 `Last In First Out(LIFO)`이다. 데이터의 추가나 삭제를 단반향으로만 가능하다.
- 접근 가능한 최상위의 데이터를 TOP이라하고 데이터를 삽입하는 것을 PUSH, 삭제하는 것을 POP이라고 한다.
- 중간 데이터에 접근하려면 최상위에서부터 데이터를 POP해야한다.
- Undo, 웹 페이지 뒤로 가기 같이 `최근성`이 중요한 경우에 사용된다.
- 초기값으로 현재 위치를 설정한다. 
      1) 현재 위치에서 갈 수 있는 곳을 스택에 PUSH하고 갈 수 있는 곳 중에 한 곳을 스택에서 POP하여 현재 위치로 설정하여 이동한다. 
      2) 이동을 했을 때 갈 수 있는 곳이 없으면 기존 스택에서 POP하여 그 위치로 이동한다. 
      3) 한번 방문했던 곳은 스택에 넣지 않는다. 
      4) 1)\~3)을 반복하면서 도착점이 나오면 탐색을 멈춘다. -> `깊이 우선 탐색`

### 큐(Queue)
- 큐는 데이터를 1열로 나열하고 임의의 객체들을 삽입한 순서대로 저장하고 들어간 순서대로 데이터를 삭제하는 자료구조이다.
- 데이터가 `들어오는 곳(rear)`과 `나가는 곳(front)`이 다르다.
- 선입선출 구조의 `First In First Out(FIFO)`이다.
- 데이터를 삽입하는 것을 ENQUE, 삭제하는 것을 DEQUE이라고 한다.
- 중간 데이터에 접근하려면 앞에서부터 데이터를 DEQUE해야한다.
- 프린터, 대기열처럼 시간의 `순서`가 중요한 영역에서 사용한다.
- 선형 큐로 큐를 구현을 한 경우 삽입이 이뤄지는 곳(front)과 삭제가 이뤄지는 곳(rear)이 계속 증가만 한다. 만약 인덱스 연산을 위해서 항목을 이동시켜야하는 경우 O(n)의 시간복잡도가 추가된다. 이를 해결하기 위해 원형 큐로 큐를 구현한다.
- 원형 큐는 front와 rear의 값이 MAX_QUEUE_SIZE-1에 도달하면 다음에 증가되는 값은 0이 되도록 하는 것이다. 개념상 원형으로 배열의 인덱스를 변환시켜준다. front는 항상 큐의 첫번쨰 요소 하나 앞을 가리키고 rear는 마지막 요소를 가리킨다.
- 초기값으로 현재 위치를 설정한다. 
      1) 현재 위치에서 갈 수 있는 곳을 큐에 ENQUE하고 갈 수 있는 곳 중에 한 곳을 큐에서 DEQUE하여 현재 위치로 설정하여 이동한다. 
      2) 이동을 했을 때 갈 수 있는 곳이 없으면 기존 큐에서 DEQUE하여 그 위치로 이동한다. 
      3) 한번 방문했던 곳은 큐에 넣지 않는다. 
      4) 1)\~3)을 반복하면서 도착점이 나오면 탐색을 멈춘다. -> `너비 우선 탐색`

### 해시 테이블(Hash Table) / 해시 맵(Hash Map)
- 해시 테이블은 해시 함수와 함께 데이터 `검색`을 효율적으로 하기 위해 사용되는 배열과 리스트의 장점을 결합한 자료구조로 이론적으로 탐색 연산의 시간 복잡도 O(1)을 보장한다. 해시 맵과 해시 테이블은 의미적으로 크게 다르지 않아 보통 같이 칭한다.
- 키 값의 연산에 의해 직접 접근이 저장이 가능한 자료구조를 해시 테이블이라고 하고 해시 테이블의 주소를 탐색하는 방법을 `해싱`이라고 한다.
- 탐색키를 해시 함수에 넣으면 인덱스로 사용할 수 없는 탐색키를 산술적인 연산을 적용하여 항목이 저장된 위치를 직접 계산하여 매핑된 `해시 주소`를 얻어낼 수 있다. 해시 함수는 탐색키를 입력 받아 해시 주소를 계산하는데 삽입과 삭제 그리고 탐색이 모두 이 주소에서 이루어진다.
- 경우에 따라서 다른 키를 넣었는데 해시 함수에 의해 같은 해시 주소가 계산될 수 있어 이미 삽입이 되어 있어 1:1 매핑이 되지 않는다면 이것을 `충돌`이라고 한다. 충돌이 적어야 좋은 해시 테이블이다.
- 일반적으로 해시 테이블에는 value만 저장하고 key는 탐색 목적으로만 사용하기도 하지만 이후 충돌 문제 처리가 어렵기 때문에 해시 테이블에 탐색을 위한 `key와 value를 모두 저장하여` 충돌 문제를 처리할 때 사용한다.
- 테이블의 크기가 M일 때 탐색키 k에 대해서 해시 함수는 `k mod M`으로 정의한다. 테이블 크기 M은 소수(prime number)를 선택하고 크게 잡아서 충돌을 최대한 적게 한다.
- 탐색키가 문자열인 경우 아스키 코드 값을 모두 더하는 방식으로 사용하여 변환한다.
- 해시에서 충돌이 나는 경우 이를 처리하는 일반적인 방법은 `선형조사법`과 `Chaining`이다.
- `선형조사법`은 충돌이 발생했다면 그 다음의 비어 있는 공간을 계속 찾고 삽입하는 방식이다. 이후의 각 앤트리의 key와 value를 비교하여 탐색하여 데이터를 얻어낼 수 있다. Open Addressing은 간단하고 추가적인 공간이 필요 없어 좋다. 그러나 충돌이 많이 발생하여 군집화 되면 탐색의 효율이 크게 저하될 수 있고 삭제 시에 메커니즘이 복잡해진다. 그래서 이에 대한 추가적인 방법을 더 정의해야한다. 예를 들어 삭제를 했을 때는 데이터를 삭제했기 때문에 비어있다고 표식을 해야한다.
- `Chaining`은 충돌이 발생했다면 같은 해시 주소로 관리되는 해시되는 데이터를 모두 연결 리스트로 관리하여 하나의 해시 주소에 여러 개의 데이터를 저장하는 방식이다. 이후의 각 앤트리의 key와 value를 모두 저장하고 비교하여 탐색하여 데이터를 얻어낼 수 있다.

### 트리(Tree)
- 트리는 그래프의 스페셜 케이스로 `사이클을 가지지 않은 연결 그래프`이다.
- 트리는 부모 자식 관계를 갖는 노드들의 집합으로서 계층적 구조를 갖는다. 그로 인해 탐색 시간이 줄어든다.
- 가장 최상단의 노드를 `루트 노드`라고 부르고 나머지 노드들을 `서브 트리`라고 부른다. 루트와 서브 트리는 선으로 연결되는데 이 연결선을 `간선` 또는 `엣지`라고 부른다.
- 트리는 각 층에 레벨을 매길 수 있는데, 자신과 연결된 상위 레벨의 노드를 `부모 노드`라고 부르고, 자신과 연결된 하위 레벨의 노드를 `자식 노드`라고 부른다. 같은 부모 노드를 두고 있는 같은 레벨의 노드는 형제 관계라고 말한다. 그리고 자식 노드가 없는 노드를 리프 노드라고 부른다.
- 이진 트리는 최대 2개의 자식 노드들만 가질 수 있는 노드들로 구현된 트리이다. 보통의 트리는 이진 트리라고 생각하면 된다.
- 구현하는 방식은 노드들을 포인터로 직접 연결하거나 index를 나타내는 배열안에 포인터를 넣어서 구현할 수 있다. 노드들을 직접 연결한 트리를 `LinkedTree`라고 부르고 배열 안에 포인터를 넣어서 구현하는 것을 `ArrayTree`라고 부른다.
- LinkedTree는 element 안에 값을 제외하고도 `부모 노드`를 가르키는 포인터 `왼쪽 자식 노드`를 가르키는 포인터 `오른쪽 자식 노드`를 가르키는 포인터 3가지가 필요하다. 이진 탐색 트리 구현 시에는 LinkedTree를 주로 이용한다.
- ArrayTree는 element 안에 값만 넣으면 된다. 왼쪽 자식의 index = `2 X 부모의 index 번호`로 오른쪽 자식의 `index = 2 X 부모의 index 번호 + 1`을 통해서 구현할 수 있다. 곱하기 연산을 위해 0번째 방은 비워둔다. Heap 구현 시에는 ArrayTree를 주로 이용한다.
- 탐색 방식은 preorder, inorder, postorder가 있다. `Preorder`는 루트를 먼저 방문하고 그 다음 왼쪽 서브 트리를 방문하고 오른쪽 서브 트리를 마지막으로 방문하는 방식이다. `Inorder`는 왼쪽 서브 트리->루트->오른쪽 서브 트리 순으로 방문하는 방식이다. `Postorder`는 왼쪽 서브 트리 -> 오른쪽 서브 트리 -> 루트 순으로 방문하는 방식이다. 각각의 탐색 방식을 순회하면 처음부터 여러 번 재귀되어 리프 노드 단까지 내려간다.
- 이진 트리 중에서 각 레벨에 노드가 꽉 차있는 트리를 포화 이진 트리라고 부르고 높이가 K인 트리에서 레벨 1\~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리를 완전 이진 트리라고 한다.
- 이진 탐색 트리, AVL 트리, Red-Black 트리, 스레드 이진 트리, B 트리, K-d 트리 등등 다양한 트리가 존재한다.

### 이진 탐색 트리(Binary Search Tree)
- 이진 탐색 트리는 이진 트리의 일종으로 탐색을 위해 만들어진 자료구조로 균형 잡힌 이진 탐색 트리는 탐색에 대한 시간 복잡도를 O(logN)을 보장한다. 완전 이진 트리의 일종이 아닌 이진 트리의 일종이다.
- 부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작거나 같은 구조를 유지한다.
- 이진 탐색 트리에서 삽입 연산은 부모 노드부터 키값을 비교하고 삽입하려는 노드의 키 값이 작으면 왼쪽 서브 트리로 크거나 같으면 오른쪽 서브 트리로 이동하고 이를 비어있을 때까지 재귀적으로 호출하고 비어있는 경우에 그 곳에 노드를 삽입한다.
- 이진 탐색 트리에서 삭제 연산은 삽입에 비해 복잡하다. 3가지 경우가 존재한다.
- 이진 탐색 트리 삭제 연산에서 자식 노드가 없는 노드를 삭제할 때는 그 노드를 삭제하면 된다.
- 이진 탐색 트리 삭제 연산에서 자식 노드가 한개 있는 노드를 삭제할 때는 해당 노드를 지우고 그 노드의 자식과 그 노드의 부모를 연결해준다.
- 이진 탐색 트리 삭제 연산에서 자식 노드가 두개 있는 노드를 삭제할 때는 해당 노드의 오른쪽 자식 노드의 서브 트리에서 가장 작은 값을 또는 왼쪽 자식 노드의 서브 트리에서 가장 큰 값을 삭제하려고 하는 노드의 부모와 자식들을 연결하고 해당 노드를 지운다. 그리고 swap 되어 비어있게 된 노드에게 자식이 존재하는 경우 swap된 노드의 부모 노드와 연결해준다. 
- 이진 탐색 트리에 Blancing 알고리즘이 추가되어 있지 않으면 삽입되는 데이터들에 따라 O(logN)의 시간 복잡도를 보장해주지 못한다. 그래서 이진 탐색 트리에 Blancing 알고리즘을 추가한 것이 AVL 트리, Red-Balck 트리 등등이다.

### 힙(Heap)
- 힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조이다. 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 `최소값 또는 최대값`을 쉽게 뽑아내기 위한 자료구조이다.
- `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰 완전 이진 트리`이다. 힙은 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도의 `느슨한 정렬 상태`를 유지한다. 삽입과 삭제 시에도 자동으로 느슨한 정렬이 유지된다.
- 기본적으로 최대 힙을 사용하지만, 키 값에 대한 트리 구조의 변화에 따라 힙의 종류가 다르다. 부모 노드의 키 값이 자식 노드보다 크거나 같은 경우를 최대 힙이라 부르고 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 경우 최소 힙이라 부른다.
- 힙은 완전 이진 트리이기 때문에 중간에 비어 있는 요소가 없다. 배열로 구현한다고 가정하면 루트 노드부터 레벨을 따라 내려오면서 번호를 매기고 배열의 인덱스로 생각하고 힙의 노드들을 저장할 수 있다.
- 트리의 모든 위치의 노드 번호는 새로운 노드가 추가되더라도 변하지 않는다. `왼쪽 자식의 인덱스는 = 부모의 인덱스*2`이고 `오른쪽 자식의 인덱스는 부모의 인덱스*2+1`이다. `부모의 인덱스는 자식의 인덱스/2`를 하면 구할 수 있다.
- 힙에 데이터를 넣고 하나씩 삭제하면서 pop된 데이터를 저장하면 heap sort를 구현할 수 있다.
- 힙에서 삽입 연산은 힙의 마지막 레벨의 마지막 노드에 이어서 삽입한다. 삽입 후에는 새로운 노드를 그 노드의 부모 노드와 키값을 보고 비교해서 힙의 성질을 만족시켜 준다. 삽입한 노드와 그 노드의 부모의 키값이 부모가 더 크면 그대로 두고 키값이 부모가 더 작으면 삽입한 노드와 부모를 교체한다. 형제 관계에 있는 노드와는 관련이 없다.
- 힙에서 삭제 연산은 루트 노드를 삭제하는 것이다. 그리고 힙의 마지막 노드를 루트로 가져온다. 이후 루트 노드와 자식의 키 값을 비교하면서 힙의 성질을 만족시킨다.
- 큐와 다르지만 유사하게 마지막 레벨의 마지막 노드에 삽입하고 루트 노드를 삭제한다.

### 우선순위 큐(Priority Queue)
- 우선 순위의 개념이 들어간 큐이다. 우선 순위가 높은 데이터가 먼저 삭제된다. `우선 순위가 가장 낮은 요소가 먼저 삭제되는 큐는 최소 우선순위 큐`라고 하고 `우선 순위가 가장 높은 요소가 삭제되는 큐는 최대 우선 순위 큐`라고 한다.
- 우선순위 큐를 구현할 수 있는 방법은 여러가지가 있으나 대부분 힙으로 구현한다. 배열로 구현하면 삽입은 O(1)이지만 삭제 시에 우선순위에 대한 정렬을 해야 하기 때문에 시간 복잡도가 O(n)이 된다. 연결 리스트로 구현하면 반대로 삽입 시에 O(n)이고 삭제 시에 O(1)이다.
- 힙을 사용하면 느슨한 정렬이 되어 있어 삭제할 루트 값에 대해서만 고려하면 되는 우선순위 큐에서 삽입과 삭제 시에 모두 O(logn)을 보장한다.
- 힙은 그 자체가 최대, 최소에 관해서는 확실하고 그 하부 구조에서도 느스한 정렬이 되어있는 상태이기 때문에 이후에 우선 순위를 결정하기 매우 쉬워 힙을 통해서 우선순위 큐를 구현한다. 다만 힙 자료구조 자체가 우선 순위 큐는 아니며 우선 순위 큐도 힙을 사용하지 않고도 매우 다양한 방식으로 구현 가능하다.

### 그래프(Graph)
- 그래프는 요소들이 복잡하게 연결되어 있는 자료구조이다.
- 경로 탐색, 네트워크 등에서 많이 사용하는 자료구조이다.
- 그래프는 `정점(Vertex)`과 `간선(Edge)`들의 집합으로 구성된다. 정점은 노드라고도 불리며 간선은 링크라고도 불린다.
- 그래프는 무방향 그래프, 방향 그래프, 가중치 그래프, 부분 그래프 등으로 나뉜다.
- `무방향 그래프`는 간선에 방향이 표시되지 않은 그래프를 의미한다. 하나의 간선은 양방향으로 갈 수 있는 길을 의미한다.
- `방향 그래프`는 간선에 방향이 표시되는 그래프이다. 화살표로 주로 표시하는데 한쪽 방향으로만 갈 수 있음을 의미한다. 그렇기 때문에 정점 A에서 정점 B로 가는 간선과 정점 B에서 정점 A로 가는 간선은 다르다.
- `가중치 그래프`는 간선에 비용이나 가중치가 할당된 그래프이다. 간선은 두 정점 간의 연결 유무뿐 아니라 연결 강도까지 나타낼 수 있다.
- `부분 그래프`는 그래프를 구성하는 정점의 부분 집합과 간선의 부분 집합으로 이루어진 그래프를 부분 그래프라고 부른다.
- 인접 정점(adjacent vertex)은 간선에 의해 직접 연결된 정점을 만한다.
- 정점의 차수(degree)는 정점에 연결된 간선의 수를 말한다.
- `경로(path)`는 간선을 따라 갈 수 있는 길을 의미하며 정점과 간선의 나열로 표현된다.
- `단순 경로(simple path)`는 반복되는 간선이 없는 경로를 단순 경로라고 한다. 단순 경로의 시작 정점과 종료 정점이 같다면 이러한 경로를 사이클이라고 한다.
- `사이클(cycle)`은 단순 경로들 중에서 시작 정점과 종료 정점이 같은 경로를 사이클이라고 한다.
- `연결 그래프(connected graph)` 모든 정점들 사이에 경로가 존재하면 연결 그래프라고 부른다.
- `트리(tree)`는 그래프의 특별한 경우로 사이클을 가지지 않은 연결 그래프이다.
- `완전 그래프(complete graph)`는 모든 정점 간에 간선이 존재하는 그래프이다.
- 그래프를 표현하는 방법에는 배열을 사용하는 `인접 행렬 방법`과 연결 리스트를 사용하는 `인접 리스트 방법` 두 가지가 있다.
- 인접 행렬을 이용한 표현에는 정점의 개수가 n개이면 n X n 2차원 배열인 인접 행렬 M을 이용하여 표현한다. 행렬 M[i][j]는 i에서 j로 가는 간선이 존재하는지를 의미한다. 존재하며 1 존재하지 않으면 0이다. 무방향 그래프에서는 M[i][j]와 M[j][i]가 같게 취급되어 대칭을 이루지만 방향 그래프에서는 대칭을 이루지 않는다. 가중치 그래프에는 0과 1이 아니라 가중치의 값이 저장되어야한다. 그렇기 때문에 연결이 되지 않은 경우에는 0이 아닌 다른 값을 사용해야 한다. 보통 가중치가 될 수 없는 엄청 큰 값을 설정하고 이를 상수로 생각하여 판단한다.
- 인접 행렬을 이용한 표현에는 두 정점을 연결하는 간선의 존재 여부를 O(1)에 알 수 있고 정점의 차수를 알기 위해선 n개의 정점을 가진 그래프에서 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 의해 알 수 있다. 모든 간선의 수를 알기 위해선 O(n\^2)의 시간이 요구된다.
- 인접 리스트를 이용한 표현에는 그래프의 각 정점에 인접한 정점들을 그 정점에 대한 연결리스트에 이어서 표현한다. 정점의 개수가 n개이면 n개의 연결 리스트가 필요하고 각각의 연결리스트 내에서 순서는 중요하지 않다. 기준 정점과 인접한 정점들을 표현만 할 뿐이다. 무방향 그래프에서는 정점 A의 인접리스트 안에 정점 B가 있으면 정점 B의 인접리스트 안에 있는 정점 A가 당연히 있지만 방향 그래프에서는 정점 A의 인접리스트 안에 정점 B가 있어도 정점 B의 인접리스트 안에 정점 A가 없을 수도 있다. 가중치 그래프에서는 인접 리스트 안에 연결 정점은 물론 가중치도 저장해야한다.
- 인접 리스트를 이용한 표현에는 한 정점에 연결된 노드의 수 k라 했을 때 두 정점을 연결하는 간선의 존재 여부와 정점의 차수를 알기 위해선 모두 O(k)에 알 수 있다. 모든 간선의 수를 알기 위해선 n개의 정점과 e개의 간선을 가진 그래프에서 O(n+e)의 시간이 요구된다.

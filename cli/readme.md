
# The Art of Command Line 학습 자료
[원문](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ko.md)의 기본 부분을 학습하고 내용을 정리 및 추가했습니다.

### Basics
* `bash`를 배우세요. 다른 쉘도 많이 존재하지만 여러 환경에서 제한이 생길 수 있습니다.
  * [Bash 정리 자료](https://blog.gaerae.com/2015/01/bash-hello-world.html?m=1)
* `vi`를 배우세요. 텍스트 터미널을 이용하는 고급 이용자라면 Vim(Vi)을 대체할 수 있는 것은 없습니다.
  * 명령 모드(default)
    1. `i`: 현재 커서를 기본으로 입력 모드로 전환
    2. `a`: 현재 커서 1칸 뒤를 기본으로 입력 모드로 전환
    3. `:`: 마지막 행 모드로 전환
    4. `x`: 커서에 있는 문자 삭제
    5. `dd`: 커서 위치의 줄 삭제
    6. `D`: 커서 위치부터 그 줄 마지막까지 삭제
    7. `^`: 현재 라인 맨 앞으로 이동
    8. `$`: 현재 라인 맨 뒤로 이동
    9. `H`: 현재 화면 맨 위로 이동
    10. `M`: 현재 화면 중간으로 이동
    11. `L`: 현재 화면 맨 마지막으로 이동
    12. `gg`: 파일의 맨 앞으로 이동
    13. `숫자 + gg`: 숫자에 해당하는 라인으로 이동
    14. `G`: 파일의 맨 끝으로 이동
    15. `yy`: 현재 커서가 있는 행 복사
    16. `p`: 현재 커서가 있는 다음 행에 복사 붙여넣기
    17. `u`: undo
  * 입력 모드
    1. `ESC`: 명령 모드로 전환
    2. `화살표`: 이동 명령
    3. `BACK`: 커서에 있는 문자 삭제
  * 마지막행 모드
    1. `ESC`: 명령 모드로 전환
    2. `:q!`: 저장하지 않고 vi 종료 
    3. `:w`: 저장
    4. `:wq!`: 저장 이후 vi 종료
    5. `/문자열`: 입력한 문자열 검색
    6. `:set nu`: 라인 표시
    7. `:set nonu`: 라인 표시 해제
* `man`을 이용해서 문서를 읽는 법을 배우세요.
* `pipe`와 `redirect`를 이용한 입력과 출력을 배우세요.
  * `>`는 출력 파일을 덮어 씌우고, `>>`는 출력 파일 끝에 내용을 덧붙입니다.
  * `|`는 어떤 프로그램의 출력 결과를 다른 프로그램의 입력 값으로 사용할 때 사용합니다.
  * stdin은 받은 입력 값을 프로그램에 나타내주는 stream입니다.
  * stdout은 모든 출력 값들이 가는 출력 stream입니다.
  * stderr은 또 다른 출력 채널입니다. 주로 디버깅 정보나 에러를 출력하는데에 쓰입니다.
    1. ps -ef > text.txt: 좌측의 stdout을 우측의 파일에 남깁니다.
    2. ps -ef | grep bash: 좌측의 stdout을 우측의 stdin으로 전달합니다.
* 파일 글롭 확장을 배우세요.
  * `*`: 와일드 카드라고 불리는 표현으로 없는 것을 포함한 어떠한 수의 문자라도 일치
  * `?`: 어떠한 하나의 문자를 일치
  * `[]`: 대괄호 안의 하나의 문자를 일치
  * `"`: 작은따옴표로 감싸진 문자열은 변화 없이 그대로 출력
  * `'`: 큰따옴표 안에 넣으면 변수가 실제 값으로 치환된 후 출력
* `bash` 작업 커맨드를 익히세요.
  * `&`: 백그라운드에서 실행하기
  * `ctrl + c`: 프로세스 강제 종료
  * `ctrl + z`: 현재 실행하고 있는 프로세스를 일시 정지하고 백그라운드로 보내기
  * `ctrl + w`: 현재 명령어 라인 전까지의 한단어 지우기
  * `ctrl + u`: 현재 명령어 라인 지우기
  * `ctrl + a`: 현재 명령어 라인 맨 앞으로 이동
  * `ctrl + e`: 현재 명령어 라인 맨 뒤로 이동
  * `!!`: 마지막 명령어 반복
  * `fg`: 다시 해당 프로세스를 포그라운드로 부르기
  * `bg`: 현재 실행하고 있는 프로세스를 정지하지 않고 백그라운드로 보내기
  * `kill`: 백그라운드 프로세스 제거하기
  * `jobs`: 현재 실행하고 있는 작업 목록 확인하기
  * `nohub`: logout 후에도 백그라운드에서 실행하기
* `ssh`를 익히세요.
  * `ssh`: 시큐어 셸(Secure Shell, SSH)은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 그 프로토콜을 가리킨다.
  * `ssh-agent`: ssh-agent는 개인키의 비밀번호를 암호화 해 기억해두고 처음 한 번만 개인키 비밀번호를 입력하면 다음부터는 기억한 비밀번호를 이용하여 접속하는 방법
  * `ssh-add`:개인키를 ssh-agent에 등록하는 방법
* 기본적인 `파일`과 `디스크` 관리 커맨드를 익히세요.
  * `ls`: 디렉토리에 있는 내용(디렉토리, 파일 등)을 확인
  * `head`: 문서의 머리(head)부분을 10줄을 출력
  * `tail`: 문서의 꼬리(tail)부분을 10줄을 출력
  * `chown`: 파일을 소유하는 유저와 그룹을 변경하기 위해서 사용 => chown {소유권자}:{그룹식별자} {소유권을 변경하고 싶은 파일명}
  * `chmod`: 파일에 대한 권한 변경하기 위해서 사용 => chmod [option (ex.744)] [변경할 파일 위치/이름]
    1. chmod 000 test.c - 사용자, 그룹, 다른사용자의 모든 권한을 제거한다.
    2. chmod 777 test.c - 사용자, 그룹, 다른사용자의 모든 권한을 추가한다.
    3. chmod 700 test.c - 사용자에게만 모든 권한을 준다.
    4. chmod 744 test.c - 사용자에게는 모든 권한을 주고, 그룹, 다른 사용자에게는 읽기 권한만 준다.
  * `du`: 디렉토리 별로 사용량을 확인
  * `cat`: 전체 파일을 출력(짧은 파일을 출력할 때 사용)
  * `more`: 전체 파일을 한 페이지씩 출력(긴 파일을 출력할 때 사용)
  * `less`: 위에서 아래, 아래에서 위로 둘 다 이동이 가능하게 긴 파일을 읽을 때 사용
* `파일시스템` 관리 커맨드를 배우세요.
  * `df`: 디스크의 사용 현황을 출력
  * `fdisk`: 파티션을 관리하는 명령어
  * `mount`: 파티션을 특정 디렉토리에 연결하여 그 파티션을 사용
  * `unmount`: 파티션을 특정 디렉토리에 연결 해제
  * `mkfs`: 포맷하는 명령어
  * `lsblk`: 블록 디바이스들의 목록(디스크들이나 디스크파 티션들)을 트리의 형태로 출력
* `메모리`와 `프로세스` 관리 커맨드를 배우세요.
  * `top`: 시스템 상태 화면을 갱신하며 정보를 보여주는 주기적인 출력
  * `ps`: 시스템 상태를 커맨드 입력 시기에 출력
  * `free`: 현재 메모리 상태를 출력
* `네트워크` 관리 커맨드를 배우세요.
  * `ifconfig`: 네트워크 인터페이스를 설정하거나 확인하는 명령어로 보통 `이더넷` 인터페이스에서 IP를 확인 가능
  * `dig`: 도메인네임에 대한 DNS 질의응답이 정상적으로 이루어지는지를 확인 점검하는 툴
  * `ping`: 네트워크에서 특정 호스트에 접근이 가능한지를 체크하는 명령어
  * `traceroute`: 출발지와 목적지 사이의 라우터를 추적하는 명령어
  * `route`: 라우팅 테이블을 편집하거나 출력하는 명령어
* `git`을 배우세요.
  * [Git 정리 자료](https://git-scm.com/book/ko/v2)
* `정규표현식`을 배우세요.
  * 정규표현식 특수기호
    1. `^`: 매칭할 문자열의 맨 앞을 타겟으로 패턴 매칭
    2. `$`: 매칭할 문자열의 맨 뒤를 타겟으로 패턴 매칭
    3. `\`: 특수기호를 패턴이 아닌 문자로 사용하고 싶으면 \{특수기호}를 사용 `ex) \$`
    4. `.`: 모든 문자와 매칭
    5. `[]`: [] 안에 있는 모든 문자를 매칭할 문자열의 문자 1개와 패턴 매칭
    6. `[-]`: [] 안에서 문자의 범위를 지정할 때 사용 `ex) [a-d]: a-d와 매칭`
    7. `[^]`: [] 안에서 문자의 범위를 제외할 때 사용 `ex) [^a-d]: a-d 이외의 문자들과 매칭`
    8. `()`: () 안에 있는 모든 문자열을 서브 그룹으로 지정하여 매칭할 문자열과 매칭 
    9. `(|)`: () 안에 있는 모든 문자열을 |을 통해 여러 개 설정하여 매칭 `ex) (abc|edf)`
    10. `*`: \* 앞에 있는 문자가 매칭할 문자열에 0개~여러 개 있을 때 최대한 Greedy 매칭 `ex) [a-z]*`
    11. `+`: \+ 앞에 있는 문자가 매칭할 문자열에 1개~여러 개 있을 때 최대한 Greedy 매칭 `ex) [a-z]+` 
    12. `?`:  \? 앞에 있는 문자가 매칭할 문자열에 0개~1개 있을 때 매칭 `ex) [a-z]?`
    13. `{숫자}`: {} 안에 있는 숫자만큼 매칭할 문자열에 매칭 `ex) [a-z]{3}`
    14. `{숫자1,숫자2}`: {} 안에 있는 숫자1보다 크거나 같고 숫자2보다 작거나 같은 숫자 만큼 매칭할 문자열에 매칭 `ex) [a-z]{1,3}`
    15. `{숫자,}`: {} 안에 있는 숫자 이상만큼 매칭할 문자열에 매칭 `ex) [a-z]{3,}`
    16. `*?`:  Greedy 수량자인 *의 Greedy 속성을 Lazy 속성으로 변환하여 해당 상황에서 0개~여러 개로 확장할 수 있는 한 Lazy 매칭 `i\w*?n`
    17. `+?`:  Greedy 수량자인 +의 Greedy 속성을 Lazy 속성으로 변환하여 해당 상황에서 1개~여러 개로 확장할 수 있는 Lazy 한 매칭 `i\w+?n`
    18. `\w`: 워드, [A-z0-9__]와 동일한 의미
    19. `\W`: 워드가 아닌 것 , 즉 [^A-z0-9__]와 동일한 의미
    20. `\d`:  숫자, [0-9]와 동일한 의미
    21. `\D`: 숫자가 아닌 것, 즉 [^0-9]와 동일한 의미
    22. `\b`: 워드 바운더리, 단어가 경계를 지정할 때 사용 ex) `\bABC\b`: ABC가 독립 `\bABC`: ABC로 시작 `ABC\b`: ABC로 종료
    23. `B`: 워드 바운러디가 아닌 것, 단어가 경계가 아닌 것을 지정할 때 사용
  * 정규표현식 패턴
    1. 전화번호: /^\d{3}-\d{3,4}-\d{4}$/
    2. 이메일: /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/i 
    3. 핸드폰번호: /^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/
    4. URL: ^(https?):\/\/([^:\/\s]+)(:([^\/]*))?((\/[^\s/\/]+)*)?\/?([^#\s\?]*)(\?([^#\s]*))?(#(\w*))?$  
  * 정규표현식 특징
    1. 정규표현식은 대소문자를 구분합니다.
    2. 정규표현식 패턴의 기본은 문자열 패턴을 그대로 매칭
    3. 공백도 문자로 인식하여 매칭 
* `grep/egrep`과 다양한 플래그를 배우세요.
  * `grep/egrep`:  특정한 패턴(문자열)을 찾는 명령어로 egrep은 grep에서 확장 정규식이 추가된 명령어
  * -i: 대소문자를 구별하지 않음
  * -v: 문자열이 제외된 라인을 출력
  * -A {숫자}: 패턴매칭라인 이후의 라인을 NUM수만큼 출력
  * -B {숫자}: 패턴매칭라인 이전의 내용을 NUM수만큼 출력.
  * -C {숫자}: 출력물 앞뒤 전후의 주어진 라인만큼 출력
* `apt-get/yum/pip/dnf/rpm`와 같은 패키지 매니저로 패키지를 찾고 설치하는 방법을 배우세요.

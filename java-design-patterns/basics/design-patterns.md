# 디자인 패턴

## Singleton 패턴
- 불필요한 객체 생성을 막고 하나의 객체를 재사용하는 패턴

## Strategy 패턴
- 동일한 틀 안에 있는 특정 작업 방식의 옵션들마다 행동들을 모듈화해서 독립적이고 상호 교체하여 실행하는 패턴
- 같은 일을 하되 알고리즘이나 방식이 바뀌는 방식

## State 패턴
- Strategy과 유사하지만, 특정 상태마다 다르게 할 일을 또는 그 상태들 자체를 그 상태마다 실행 시 할 일과 함께 모듈화해서 지정해서 실행하는 패턴

## Command 패턴
- Strategy 유사하지만, 하는 일 자체가 여러 가지 다른 방식을 모듈화해서 독립적으로 실행하는 패턴

## Adapter 패턴
- 클래스의 인터페이스를 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하게 만드는 패턴

## Proxy 패턴
- 프록시 객체를 만들어 기본 객체의 무거운 기능을 앞단에서 처리하거나 부가 기능을 추가하는 패턴

## Facade 패턴
- 작업을 할 때마다 여러 클래스들에 하나 하나 접근하는 방식이 아닌 사용자 측에서 복잡한 과정을 하나의 과정으로 간추려 사용하는 패턴

## Template-method 패턴
- 어떤 같은 형식을 지닌 특정 작업에 추가적으로 작업 방식을 다양하게 하고 싶을 때 사용하는 패턴

## Decorator 패턴
- 특정 클래스에 객체들이 할 수 있는 일을 여러가지 두고 각 개체마다 사용자가 원하는 대로 골라 시키거나 기능들을 필요에 따라 장착시키는 패턴

## Factory-method 패턴
- 팩토리 클래스를 정의하고 객체를 생성하고 가져오는 일을 하나에서 처리하여 생성하는 곳과 사용하는 곳을 분리하고 팩토리 클래스에 조건을 쉽게 추가할 수 있게 간단화하는 패턴

## Abstract-factory-method 패턴
- 팩토리 메서드에 한 단계 더 추상화한 패턴

## Mediator 패턴
- 클래스의 객체에서 특정 이벤트가 발생할 때마다 다른 클래스에게 알려야하는 경우 중재자를 만들어서 통합하여 사용하는 패턴

## Composite 패턴
- 포함하는 것들과 포함되는 것들이 같은 방식으로 디뤄질 수 있도록 할 때 사용하는 패턴
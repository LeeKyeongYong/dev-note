# 직렬화
객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하는 것을 의미하고, 바이트 스트림으로부터 다시 객체로 재구성하는 것은 역직렬화를 의미한다.

## 아이템 85 자바 직렬화의 대안을 찾으라
- 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 넓어져서 방어하기 어렵다는 점이다.
- 직렬화의 위험을 회피하는 가장 좋은 방법은 `아무 것도 역직렬화하지 않는 것`이다.
- `새로운 시스템에서는 자바 직렬화를 써야할 이유가 전혀 없다.`
- 자바 직렬화 대신 JSON이나 protobuf를 사용하라.
- JSON은 브라우저와 서버의 통신용으로 설계했는데, 텍스트 기반으로 사람에게 유용하다.
- 프로토콜 버퍼는 서버 사이의 데이터 교환과 저장을 위해 설계 했는데, 이진 구조라서 성능이 빠르다.
- 직렬화를 무조건 해야되는 상황이고 역질렬화한 데이터가 안전한지 확신할 수 없다면 역직렬화 필터링인 `java.io.ObjectInputFilter`를 사용하자.

## 아이템 86 Serializable을 구현할지는 신중히 결정하라
- 어떤 클래스의 인스턴스를 직렬화 할 수 있게 하려면 클래스 선언에 `implements serializable`만 붙이면 된다.
- 직렬화를 구현하고 릴리즈한 이후에는 수정하기 어렵다.
- 직렬화 구현의 문제
  - 직렬화 형태는 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶여버린다.
  - 버그와 보안의 구멍이 생길 위험이 높아진다.
  - 해당 클래스의 신버전을 릴리즈할 때 테스트할 것이 늘어난다.
- 직렬화 구현 여부는 가볍게 결정할 사안이 아니다.
- 상속용으로 설계된 클래스는 절대로 `Serializable`을 구현하면 안 되며, 인터페이스도 대부분 `Serializable`을 확장해서는 안된다.

## 아이템 87 커스텀 직렬화 형태를 고려해보라
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 `readObject 메서드`를 제공해라
- 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용했을 때의 문제점
  1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
  2. 너무 많은 공간을 차지할 수 있다.
  3. 시간이 너무 많이 걸릴 수 있다.
  4. 스택 오버플로를 일으킬 수 있다.
- `transient` 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시이다.-
- `transient` 한정자가 있더라도 `writeObject`와 `readObejct` 메서드는 각각 먼저 defaultWriteObject와 defaultReadObject를 호출한다.
- 어떤 직렬화 형태를 택하든 직렬화 기능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
- 구버전으로 직렬화된 인스턴스들과 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.

## 아이템 88 readObject 메서드는 방어적으로 작성하라
- readObject 메서드는 매개변수로 바이트 스트림을 받는 생성자라고 할 수 있다.
- 참조를 추가하면 가변 객체 인스턴스를 만들어 낼 수도 있기에 객체를 역직렬화할 때는 클라이언트가 소유해서는 안되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사애햐한다.

## 아이템 89 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라
- 역질렬화한 객체의 클래스가 readResolve 메서드가 적절히 정의해뒀다면, 역질렬화 후 새로 생성된 객체를 인수로 이 메서드가 호출되고, 이 메서드가 반환한 객체 참조가 새로 생성된 객체를 대신해 반환된다.
- readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 `transient`로 선언해야한다.
- readResolve 메서드를 사용해 순간적으로 만들어진 역직렬화된 인스턴스에 접근하지 못하게 하는 방법은 깨지 쉽고 신경을 많이 써야하는 작업이므로 `열거 타입`을 이용해 구현하여 자바의 도움을 받아라.

## 아이템 90 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
- Serializable을 구현하기로 결정한 순간 언어의 정상 메커니즘인 생성자 이외의 인스턴스르 생성할 수 있는 방법이 생긴 것이고 이와 함께 버그와 보안에 문제가 생길 가능성이 생긴 것이다.
- `직렬화 프록시 패턴`을 사용하면 버그와 보안 문제가 생길 가능성을 크게 줄여줄 수 있다.
- 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 private static으로 선언하여 중첩 클래스인 직렬화 프록시를 만들 수 있다.
- 직렬화 프록시인 중첩 클래스의 생성자는 하나여야하며 바깥 클래스를 매개변수로 받아야한다.
- `직렬화 프록시 패턴`에도 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없으며, 객체 그래프에 순환이 있는 클래스에도 적용할 수 없다는 단점이 있다.
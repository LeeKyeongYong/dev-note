# 자바 스터디
[스터디 할래](https://github.com/whiteship/live-study) 정리

Table of contents
=================
<!--ts-->
   * [JVM](#JVM)
   * [데이터 타입 변수 배열](#데이터-타입-변수-배열)
   * [연산자](#연산자)
   * [제어문](#제어문)
   * [클래스](#클래스)
   * [상속](#상속)
   * [패키지](#패키지)
   * [인터페이스](#인터페이스)
   * [예외처리](#예외처리)
   * [멀티쓰레드](#멀티쓰레드)
   * [Enum](#Enum)
   * [애노테이션](#애노테이션)
   * [IO](#IO)
   * [제네릭](#제네릭)
   * [람다식](#람다식)
<!--te-->

JVM
=======
- JVM이란 무엇인가
  - JVM: JAVA Virtial Machine의 약자로 `Java Byte Code를 OS에 맞게 해석해주는 역할을 하는 가상머신`
  > JVM을 통해 OS에 의존없이 바이트 코드를 실행할 수 있지만, OS 별로 JVM은 필요함
  - JVM 활용 순서
    - 자바 컴파일러(javac)는 .java 파일을 .class라는 Java byte code로 변환
    - JVM은 OS가 Byte 코드를 이해할 수 있도록 해석
    - Byte 코드는 JVM 위에서 OS 상관없이 실행

- 컴파일 하는 방법 및 실행하는 방법
  - javac 는 자바 소스코드를 컴파일할 때 사용하는 프로그램이며 컴파일된 바이트 코드를 실행할 때 java 사용하여 실행
  - `$ javac 소스파일명.java`
  - `$ java 소스파일명`

- 컴파일 타임과 런타임
  - 런타임: 컴파일 과정을 마친 응용 프로그램이 사용자에 의해서 실행되는 때
  - 런타임 오류 : 0나누기 오류, 널(Null)참조 오류, 메모리 부족 오류
  - 컴파일타임: 소스코드가 컴파일러에 의해 컴퓨터가 이해할 수 있는 기계어 코드로 변환되는 때
  - 컴파일타임 오류: 신택스 오류, 타입체크 오류

- 바이트코드란 무엇인가
  - Byte 코드: 0과 1로 구성되어 있는 이진 코드이지만 일반적인 바이너리 코드와 다르게 가상 머신이 이해할 수 있는 바이너리 코드

- JIT 컴파일러란 무엇이며 어떻게 동작하는지
  - Java를 실행할 때 사용되는 컴파일러로 바이트코드를 읽어 기계어로 번역하지만 프로그램에는 반복적으로 사용하는 코드가 존재할 때 최초 1회만 번역하여 캐싱한 뒤 추가 참조가 필요할 때마다 불러와서 성능 향상시키는 기능을 가진 인터프리와 동시에 동작하는 컴파일러

- JVM 구성 요소
  - `Class Loader`
    - Runtime 시점에 .class에서 바이트 코드를 읽고 JVM의 메모리에 저장하는 요소
    - 로딩: 클래스를 읽어오는 과정
    - 링크: 레퍼런스를 연결하는 과정
    - 초기화: static 값들을 초기화 및 변수에 할당
  - `Runtime Data Areas`
    - JVM의 메모리 영역
    - Heap 과 Method는 모든 쓰레드가 공유하고 나머지는 쓰레드마다 생성
      - PC Register: CPU가 Instruction을 수행하는 동한 필요한 정보를 저장
      - Stack: Thread가 시작될 때 생성되며 Method와 Method 정보 저장
      - Navtive Method Stack: Java 이외의 언어로 작성된 native 코드를 위한 Stack
      - Method: 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수등의 바이트 코드 등을 보관)
      - Heap: 런타임시 동적으로 할당하여 사용하는 영역 class를 통해 instance를 생성하면 Heap에 저장됨
        - Heap의 경우 명시적으로 만든 class와 암묵적인 static 클래스(.class 파일의 class)가 담긴다.
        - 또한 암묵적인 static 클래스의 경우 클래스 로딩 시 class 타입의 인스턴스를 만들어 힙에 저장한다. 이는 Reflection에 등장한다.
  - `Execution Engine`
    - Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트 코드는 Execution Engine에 의해 실행
    - Load된 Class의 ByteCode를 실행하는 Runtime Module로 인터프리터, JIT 컴파일러, GC를 포함
  - `Native Method Interface(JNI)`
    - Java Native Interface(JNI)는 자바 가상 머신(JVM)위에서 실행되고 있는 자바코드가 네이티브 응용 프로그램 그리고 다른 언어들로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크

- JDK와 JRE의 차이
  - `JRE`: JRE는 자바 실행환경(Java Runtime Environment)의 약자로 JRE는 JVM 이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음
  - `JDK`: JDK는 자바 개발도구(Java Development Kit)의 약자로 JRE에 개발을 위해 필요한 도구(javac, java)를 포함

데이터 타입 변수 배열
=======
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값

  |타입|크기|범위|기본 값| 비고 |
  |---|---|---|----|-----|
  |byte| 1 byte|	-128 ~ 127	|0	|
  |short|	2 bytes|	-32,768 ~ 32,767	|0	|
  |(signed) int| 4 bytes|	-2^{31}  ~  2^{31}-1	|0	|
  |unsigned int| 4 bytes|	0  ~  2^{32}-1	|0|	java 8 이상부터 가능|
  |(signed) long|	8 bytes|	-2^{63}  ~  2^{63}-1	|0L|	
  |unsigned long|	8 bytes|	0  ~  2^{64}-1	|0L	|java 8 이상부터 가능|
  |float|	4 bytes|	single-precision 32-bit	|0.0f|	|
  |double| 8 bytes|	double-precision 64-bit	|0.0d|	|
  |boolean|	1 bit|	true / false	|false|	|
  |char| 2 bytes|	'\u0000' ~ '\uffff'	|'\u0000'|	|

- 프리미티브 타입과 레퍼런스 타입
  - **Primitive type**
    - byte, short, signed/unsigned int, signed/unsigned long, float, double, boolean, char
    - not object
    - 값 저장
    - 스택에 만들어짐
- **Reference type**
    - class, interface, enum, array, String type
    - 주소 저장
    - 힙에 만들어짐(가르키는 변수는 스택에 만들어짐)

- 리터럴
  - 리터럴은 변수나 상수에 저장되는 값 그 자체를 의미
  - 정수 리터럴
    - 정수 리터럴은 기본적으로 int 형이고, long 타입을 표현하려면 l이나 L을 마지막에 붙임
    - 기본적으로 10진법이고 0이 앞에 붙으면 8진법, 0x가 붙으면 16진법, 0b가 붙으면 2진법
    > 숫자가 매우 큰 경우는 리터럴 대신 BigInteger를 사용해야함
  - 실수 리터럴
    - 실수 리터널의 리터럴은 기본적으로 double 타입이고, float 타입으로 표현하려면 f를 명시적으로 붙임
    > 숫자가 매우 큰 경우는 리터럴 대신 BigDecimal를 사용해야함
  - 문자 리터럴
    - 문자는 작은따옴표(')안에 표현
  - 문자열 리터럴
    - 문자열은 큰따옴표(")안에 표현
  - boolean 리터럴
    - true, false 로 표현

- 변수 선언 및 초기화하는 방법
  - 변수 선언: 저장공간을 확보하겠다는 의미
  - 변수 초기화: 변수를 사용하기 전 처음으로 값을 저장하는 것

- 변수의 스코프와 라이프타임
  - `스코프`: 코프란 해당 변수를 사용할 수 있는 영역 범위
  - `라이프 타임`: 해당 변수가 메모리에 언제까지 살아있느지를 의미
  - 변수의 종류 

    |종류|의미|스코프|라이프타임| 비고 |
    |---|---|---|----|-----|
    |인스턴스 변수| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않은 변수|static method를 제외한 클래스 전체|클래스를 인스턴스화한 객체가 메모리에서 사라질 때 까지|
    |클래스 변수(전역변수)| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않았으며 static 키워드가 포함되어 선언된 변수|클래스 전체|프로그램 종료시 까지|
    |지역 변수| 인스턴스 변수, 클래스 변수가 아닌 모든 변수|변수가 선언된 블럭 내부|변수가 선언된 블럭 내부에 있는 동안|

- 타입 변환, 캐스팅 그리고 타입 프로모션
  - 타입 변환: 변수나 리터럴의 타입을 다른 타입으로 변환하는 것
  - 타입 캐스팅: 타입캐스팅이란 크기가 더 큰 자료형을 크기가 더 작은 자료형에 대입하는 것, 데이터 손실이나 변형이 올 수 있음으로 명시적으로 `(자료형)`을 적어야함
  - 타입 프로모션: 기가 더 작은 자료형을 더 큰 자료형에 대입하는 것, 데이터 손실이나 변형이 오지 않음으로 캐스팅할 때 처럼 명시적으로 적지 않아도 자동으로 변환이 가능

- 배열 선언하기
  - 배열 선언: [] 혹은 변수명 뒤에 [] 붙여서 선언하고 new 연산이나 할당 연산을 통해서 초기화
  - 배열은 객체로 Runtime Stack 영역의 힙 영역 주소값을 가지고 값은 힙에 저장되는 방식
  ```java
  int [] arr; // 추천 방법
  int arr [];
  int arr2 [] = new int[10]; 
  int arr2 [][] = new int[10][10]; 
  int[] oneDimensionArrayEx1 = {1, 2, 3, 4, 5};
  int[][] twoDimensionArrayEx1 = {{1, 2}, {3, 4}};
  ```

- 타입 추론, var
  - 

연산자
=======


제어문
=======


클래스
=======


상속
=======


패키지
=======


인터페이스
=======


예외처리
=======


멀티쓰레드
=======


Enum
=======


애노테이션
=======


IO
=======


제네릭
=======


랑다식
=======


# 자바 스터디
[스터디 할래](https://github.com/whiteship/live-study) 정리

Table of contents
=================
<!--ts-->
   * [JVM](#JVM)
   * [데이터 타입 변수 배열](#데이터-타입-변수-배열)
   * [연산자](#연산자)
   * [제어문](#제어문)
   * [클래스](#클래스)
   * [상속](#상속)
   * [패키지](#패키지)
   * [인터페이스](#인터페이스)
   * [예외처리](#예외처리)
   * [멀티쓰레드](#멀티쓰레드)
   * [Enum](#Enum)
   * [애노테이션](#애노테이션)
   * [IO](#IO)
   * [제네릭](#제네릭)
   * [람다식](#람다식)
<!--te-->

JVM
=======
- JVM이란 무엇인가
  - JVM: JAVA Virtial Machine의 약자로 `Java Byte Code를 OS에 맞게 해석해주는 역할을 하는 가상머신`
  > JVM을 통해 OS에 의존없이 바이트 코드를 실행할 수 있지만, OS 별로 JVM은 필요함
  - JVM 활용 순서
    - 자바 컴파일러(javac)는 .java 파일을 .class라는 Java byte code로 변환
    - JVM은 OS가 Byte 코드를 이해할 수 있도록 해석
    - Byte 코드는 JVM 위에서 OS 상관없이 실행

- 컴파일 하는 방법 및 실행하는 방법
  - javac 는 자바 소스코드를 컴파일할 때 사용하는 프로그램이며 컴파일된 바이트 코드를 실행할 때 java 사용하여 실행
  - `$ javac 소스파일명.java`
  - `$ java 소스파일명`

- 컴파일 타임과 런타임
  - 런타임: 컴파일 과정을 마친 응용 프로그램이 사용자에 의해서 실행되는 때
  - 런타임 오류 : 0나누기 오류, 널(Null)참조 오류, 메모리 부족 오류
  - 컴파일타임: 소스코드가 컴파일러에 의해 컴퓨터가 이해할 수 있는 기계어 코드로 변환되는 때
  - 컴파일타임 오류: 신택스 오류, 타입체크 오류

- 바이트코드란 무엇인가
  - Byte 코드: 0과 1로 구성되어 있는 이진 코드이지만 일반적인 바이너리 코드와 다르게 가상 머신이 이해할 수 있는 바이너리 코드

- JIT 컴파일러란 무엇이며 어떻게 동작하는지
  - Java를 실행할 때 사용되는 컴파일러로 바이트코드를 읽어 기계어로 번역하지만 프로그램에는 반복적으로 사용하는 코드가 존재할 때 최초 1회만 번역하여 캐싱한 뒤 추가 참조가 필요할 때마다 불러와서 성능 향상시키는 기능을 가진 인터프리와 동시에 동작하는 컴파일러

- JVM 구성 요소
  - `Class Loader`
    - Runtime 시점에 .class에서 바이트 코드를 읽고 JVM의 메모리에 저장하는 요소
    - 로딩: 클래스를 읽어오는 과정
    - 링크: 레퍼런스를 연결하는 과정
    - 초기화: static 값들을 초기화 및 변수에 할당
  - `Runtime Data Areas`
    - JVM의 메모리 영역
    - Heap 과 Method는 모든 쓰레드가 공유하고 나머지는 쓰레드마다 생성
      - PC Register: CPU가 Instruction을 수행하는 동한 필요한 정보를 저장
      - Stack: Thread가 시작될 때 생성되며 Method와 Method 정보 저장
      - Navtive Method Stack: Java 이외의 언어로 작성된 native 코드를 위한 Stack
      - Method: 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수등의 바이트 코드 등을 보관)
      - Heap: 런타임시 동적으로 할당하여 사용하는 영역 class를 통해 instance를 생성하면 Heap에 저장됨
        - Heap의 경우 명시적으로 만든 class와 암묵적인 static 클래스(.class 파일의 class)가 담긴다.
        - 또한 암묵적인 static 클래스의 경우 클래스 로딩 시 class 타입의 인스턴스를 만들어 힙에 저장한다. 이는 Reflection에 등장한다.
  - `Execution Engine`
    - Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트 코드는 Execution Engine에 의해 실행
    - Load된 Class의 ByteCode를 실행하는 Runtime Module로 인터프리터, JIT 컴파일러, GC를 포함
  - `Native Method Interface(JNI)`
    - Java Native Interface(JNI)는 자바 가상 머신(JVM)위에서 실행되고 있는 자바코드가 네이티브 응용 프로그램 그리고 다른 언어들로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크

- JDK와 JRE의 차이
  - `JRE`: JRE는 자바 실행환경(Java Runtime Environment)의 약자로 JRE는 JVM 이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음
  - `JDK`: JDK는 자바 개발도구(Java Development Kit)의 약자로 JRE에 개발을 위해 필요한 도구(javac, java)를 포함

데이터 타입 변수 배열
=======
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값

  |타입|크기|범위|기본 값| 비고 |
  |---|---|---|----|-----|
  |byte| 1 byte|	-128 ~ 127	|0	|
  |short|	2 bytes|	-32,768 ~ 32,767	|0	|
  |(signed) int| 4 bytes|	-2^{31}  ~  2^{31}-1	|0	|
  |unsigned int| 4 bytes|	0  ~  2^{32}-1	|0|	java 8 이상부터 가능|
  |(signed) long|	8 bytes|	-2^{63}  ~  2^{63}-1	|0L|	
  |unsigned long|	8 bytes|	0  ~  2^{64}-1	|0L	|java 8 이상부터 가능|
  |float|	4 bytes|	single-precision 32-bit	|0.0f|	|
  |double| 8 bytes|	double-precision 64-bit	|0.0d|	|
  |boolean|	1 bit|	true / false	|false|	|
  |char| 2 bytes|	'\u0000' ~ '\uffff'	|'\u0000'|	|

- 프리미티브 타입과 레퍼런스 타입
  - **Primitive type**
    - byte, short, signed/unsigned int, signed/unsigned long, float, double, boolean, char
    - not object
    - 값 저장
    - 스택에 만들어짐
- **Reference type**
    - class, interface, enum, array, String type
    - 주소 저장
    - 힙에 만들어짐(가르키는 변수는 스택에 만들어짐)

- 리터럴
  - 리터럴은 변수나 상수에 저장되는 값 그 자체를 의미
  - 정수 리터럴
    - 정수 리터럴은 기본적으로 int 형이고, long 타입을 표현하려면 l이나 L을 마지막에 붙임
    - 기본적으로 10진법이고 0이 앞에 붙으면 8진법, 0x가 붙으면 16진법, 0b가 붙으면 2진법
    > 숫자가 매우 큰 경우는 리터럴 대신 BigInteger를 사용해야함
  - 실수 리터럴
    - 실수 리터널의 리터럴은 기본적으로 double 타입이고, float 타입으로 표현하려면 f를 명시적으로 붙임
    > 숫자가 매우 큰 경우는 리터럴 대신 BigDecimal를 사용해야함
  - 문자 리터럴
    - 문자는 작은따옴표(')안에 표현
  - 문자열 리터럴
    - 문자열은 큰따옴표(")안에 표현
  - boolean 리터럴
    - true, false 로 표현

- 변수 선언 및 초기화하는 방법
  - 변수 선언: 저장공간을 확보하겠다는 의미
  - 변수 초기화: 변수를 사용하기 전 처음으로 값을 저장하는 것

- 변수의 스코프와 라이프타임
  - `스코프`: 코프란 해당 변수를 사용할 수 있는 영역 범위
  - `라이프 타임`: 해당 변수가 메모리에 언제까지 살아있느지를 의미
  - 변수의 종류 

    |종류|의미|스코프|라이프타임| 비고 |
    |---|---|---|----|-----|
    |인스턴스 변수| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않은 변수|static method를 제외한 클래스 전체|클래스를 인스턴스화한 객체가 메모리에서 사라질 때 까지|
    |클래스 변수(전역변수)| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않았으며 static 키워드가 포함되어 선언된 변수|클래스 전체|프로그램 종료시 까지|
    |지역 변수| 인스턴스 변수, 클래스 변수가 아닌 모든 변수|변수가 선언된 블럭 내부|변수가 선언된 블럭 내부에 있는 동안|

- 타입 변환, 캐스팅 그리고 타입 프로모션
  - 타입 변환: 변수나 리터럴의 타입을 다른 타입으로 변환하는 것
  - 타입 캐스팅: 타입캐스팅이란 크기가 더 큰 자료형을 크기가 더 작은 자료형에 대입하는 것, 데이터 손실이나 변형이 올 수 있음으로 명시적으로 `(자료형)`을 적어야함
  - 타입 프로모션: 기가 더 작은 자료형을 더 큰 자료형에 대입하는 것, 데이터 손실이나 변형이 오지 않음으로 캐스팅할 때 처럼 명시적으로 적지 않아도 자동으로 변환이 가능

- 배열 선언하기
  - 배열 선언: [] 혹은 변수명 뒤에 [] 붙여서 선언하고 new 연산이나 할당 연산을 통해서 초기화
  - 배열은 객체로 Runtime Stack 영역의 힙 영역 주소값을 가지고 값은 힙에 저장되는 방식
  ```java
  int [] arr; // 추천 방법
  int arr [];
  int arr2 [] = new int[10]; 
  int arr2 [][] = new int[10][10]; 
  int[] oneDimensionArrayEx1 = {1, 2, 3, 4, 5};
  int[][] twoDimensionArrayEx1 = {{1, 2}, {3, 4}};
  ```
- 타입 추론, var
  - 타입 추론: 데이터 타입을 소스코드에 명시하지 않아도, `컴파일 단계에서 컴파일러가 타입을 유추`해 정해주는 것
  - Java 5부터 추가된 Generic, Java 10부터 추가된 var가 타입 추론의 대표 기능
  - Generic(primitive type 사용 불가)
    - 제네릭 메소드: `<T> 반환형 매소드 이름(매개변수)` 방식으로 선언하여, 반환형과 매개변수의 데이터 타입을 함수를 호출할 때 결정
    - 제네릭 클래스: `class 클래스이름<T>` 방식으로 선언하여, 클래스 내부에서 사용하는 데이터의 타입을 클래스의 인스턴스를 생성할 때 결정
    > 자바의 모든 객체는 Object 상속하므로 다형성을 통해서 제네릭과 유사한 기능을 활용할 수있지만 형변환을 자주 해야하는 문제가 있음 
  - var
    - Local Variable Type Inference은 로컬 변수 선언을 var를 이용하여 기존의 엄격한 타입 선언방식에서 컴파일러에게 타입추론 책임을 위임하는 기능



연산자
=======
- 산술 연산자
  - 더하기: +는 기본적으로 두 수를 더하는 연산이지만 문자열을 연결시키는데도 사용, +의 피연산자 중 문자열이 있다면 다른 피연산자도 문자열로 변환
  - 빼기: - 연산자는 첫번째 피연산자에서 두번째 피연산자를 빼는 연산
  - 곱하기: * 연산자는 두 피연산자를 곱하는 연산
  - 나누기: / 연산자는 첫번째 피연산자를 두번째 피연산자로 나누는 연산
  - 나머지 연산: % 연산자는 첫번째 피연산자를 두번째 피연산자로 나누고 남은 나머지를 정수로 리턴하는 연산
  - 단항 마이너스 연산: 연산자를 단항 연산자로 사용하면 값의 부정이 수행되는 연산
- 비트 연산자: 비트 연산자(Bitwise Operators) 및 시프트 연산자(Shift Operators)는 개별 비트를 조작하는 저수준 연산자
  - `~`: 비트 반전 또는 비트 NOT 연산자로 각 비트를 반전시켜 1을 0으로, 0을 1로 변환
  - `&`: & 연산자는 두 정수 피연산자를 AND 연산(비트 곱)
  - `|`: | 연산자는 두 정수 피연산자를 OR 연산(비트 합)
  - `^`: ^ 연산자는 두 정수 피연산자를 XOR 연산, 비트가 같으면 0으로 다르면 1을 리턴
  - `<<`: << 연산자는 비트를 왼쪽으로 두번째 피연산자로 제시된 비트 수 만큼 이동, 기존의 가장 왼쪽 비트는 삭제되고 가장 오른쪽 비트는 0
  - `>>`: >> 연산자는 왼쪽 시프트 연산과 반대로 우측으로 두번째 피연산자로 제시된 비트 수 만큼 이동, 기존의 값이 양수인 경우 가장 왼쪽 비트는 0으로 채워지고 음수인 경우는 1

- 관계 연산자
  - `==`: == 연산자는 Primitive Type를 비교할 때 두 피연산자의 값이 같다면 true를 그렇지 않다면 false를 리턴 
  - `!=`: 두 피연산자의 값이 다른지 여부를 체크하여 true/false를 리턴
  - `<`: 첫번째 피연산자가 두번째 피연산자보다 작은지 여부를 리턴
  - `<=`: 첫번째 피연산자가 두번째 피연산자보다 작거나 같은지까지 여부를 리턴
  - `>`: 첫번째 피연산자가 두번째 피연산자보다 큰지 여부를 리턴
  - `>=`: 첫번째 피연산자가 두번째 피연산자보다 크거나 같은지까지 여부를 리턴

- 논리 연산자
  - `&&`: 두 피연산자가 모두 true인지 여부를 평가하며 두 피연산자 중 하나라도 false라면 false를 리턴
  - `||`: 두 피연산자 중 하나라도 true 라면 true를 리턴
  > 단락 회로 평가: &&와 || 연산을 사용할 때 첫 번째 피연산자의 결과에 따라 결과 값이 정해졌을 때 두 번째 피연산자의 평가를 하지 않는 것
  - `!`: 단항 연산자로 해당 값의 결과의 반대를 리턴

- instanceof
  - 객체(Object) 또는 배열(Array) 값을 어떠한 참조 유형에 맞는 값인지를 평가하는 연산자
  - null을 연산한다면 항상 false가 리턴
  ```java
  "Apple" instanceof String // true
  null instanceof String // false
  
  Object o = new int[]{1, 2, 3};
  o instanceof int[] // true
  ```
  > 일반적으로 instanceof를 사용하지 않는 것이 좋음

- 대입 연산자
  - 어떠한 변수에 값을 할당할 때 사용하는 연산자

- 화살표(->) 연산자
  - `->`: 람다 표현식(Lamda Expression) 이라고 하며 메소드 본문에 해당 실행 가능한 자바 코드의 익명 컬렉션
  > 함수형 프로그래밍은 간단히 말하자면 함수의 입력만을 의존해서 출력을 만드는 구조로 외부의 상태를 변경하는 것을 줄여 부작용 발생을 최소화 하는 방법론
  - 반환 타입과 메서드 이름 없이 `(Parameter 매개 변수) -> {Body 함수 몸체}` 형태로, 람다는 익명 함수의 매개변수와 리턴변수를 통해 만들어 짐
  ```java
  Runnable r = () -> {
    System.out.println("1");
    System.out.println("2");
  }

  // 코드가 한 문장이면 중괄호 생략 가능
  Runnable r = () -> System.out.println("1");
  ```

- 3항 연산자
  - `? :`: `조건 ? true일때 결과 : false 일때 결과`, if ~ else 문장을 연산자로 표현할 수 있고 조건에 따라 결과를 반환
  ```java
  public int max(int x, int y) {
    return x > y ? x : y;
  }
  ```

- 연산자 우선 순위

우선 순위 | 연산자 | 설명
| :---: | :---: | :---: |
1 | expr++ expr-- | 후위 증가/감소 연산자
2 | ++expr --expr +expr -expr ~ ! | 전위 증가/감소 연산자, 양/음 부호, 논리/비트 NOT 연산자
3 |	* ㅤ / ㅤ %	 | 곱셈/나눗셈/나머지 연산자
4 |	+ ㅤ -	 | 덧셈/뺄셈 연산자
5 |	<< ㅤ >> ㅤ >>>	 | 비트 왼쪽/오른쪽 Shift 연산자, Unsigned Shift 연산자
6 |	< ㅤ > ㅤ <= ㅤ >= ㅤ instanceof	 | 보다 작은/보다 큰/보다 작거나 같은/보다 크거나 같은 관계 연산자, instanceof
7 |	== ㅤ !=	| 와 같은/와 다른 관계 연산자
8 |	&	| 비트 AND 연산자
9 |	^	|비트 XOR 연산자
10 |	`|`	| 비트 OR 연산자
11 |	&&	| 논리 AND 연산자
12 |	`||`	| 논리 OR 연산자
13 |	? :	| 삼항 조건 연산자
14 |	= ㅤ += ㅤ -= ㅤ *= ㅤ /= ㅤ %= ㅤ &= ㅤ ^= ㅤ `|=` ㅤ <<= ㅤ >>= ㅤ >>>=	| 대입 연산자 및 복합 대입 연산자

제어문
=======
- 선택문
  - switch 문: 값을 입력 받고 그 값의 경우로 분기하여 실행하는 키워드
  ```java
  switch(domain){
    	case 1:
        break;
	    case 2:
		    break;
		    .
		    .
		    .
	    default:
		    break;
  }
  ```
  - if 문: 조건을 판단하고 참이면 if 블럭을 실행하는 키워드
  ```java
  if (expression){
    	statement;
  }
  ```
  - if else 문: 조건을 판단하고 참이면 if 블럭을 실행하고 거짓이면 else 블럭을 실행하는 키워드
  ```java
  if (expression){
    statement;
  } else {
    statement2;
  }
  ```
  - if else if 문: 여러 조건을 판단하고 if, else if 블럭 중에 참이 있으면 실행하고 아니면 else 블럭을 실행하는 키워드
  ```java
  if (expression){
    statement;
  } else if (expression2){
	  statement2;
  } 
  .
	.
	.
  else {
	  statement10;
  }
  ```
- 반복문
  - while: 조건을 검사하고 참이면 반복하는 키워드
  ```java
  while (expression){
    statement;
  }
  ```
  - do while: 명령을 최소 1번은 수행하고 조건을 검사하고 참이면 반복하는 키워드
  ```java
  do {
    statement;
  }
  while (expression)
  ```
  - for: 반복할 횟수를 지정하여 반복하는 키워드
  ```java
  for (변수 초기화; expression; statement) {
    statement;
  }
  ```
  - for each: 반복 가능한 객체가 있을 때 반복할 횟수를 제어하여 반복하는 키워드
  ```java
  for (타입 변수명 : iterable 객체) {
    statement;
  }
  ```
- 제어문
  - break: 반복문 중 반복을 종료할 수 있는 키워드
  - continue: 반복문 중 특정 조건 하에서 명령문 실행을 skip할 수 있는 키워드

클래스
=======


상속
=======


패키지
=======


인터페이스
=======


예외처리
=======


멀티쓰레드
=======


Enum
=======


애노테이션
=======


IO
=======


제네릭
=======


랑다식
=======


# 자바 스터디
[스터디 할래](https://github.com/whiteship/live-study) 정리

Table of contents
=================
<!--ts-->
   * [JVM](#JVM)
   * [데이터 타입 변수 배열](#데이터-타입-변수-배열)
   * [연산자](#연산자)
   * [제어문](#제어문)
   * [클래스](#클래스)
   * [상속](#상속)
   * [패키지](#패키지)
   * [인터페이스](#인터페이스)
   * [예외처리](#예외처리)
   * [멀티쓰레드](#멀티쓰레드)
   * [Enum](#Enum)
   * [애노테이션](#애노테이션)
   * [IO](#IO)
   * [제네릭](#제네릭)
   * [람다식](#람다식)
<!--te-->

JVM
=======
- JVM이란 무엇인가
  - JVM: JAVA Virtial Machine의 약자로 `Java Byte Code를 OS에 맞게 해석해주는 역할을 하는 가상머신`
  > JVM을 통해 OS에 의존없이 바이트 코드를 실행할 수 있지만, OS 별로 JVM은 필요함
  - JVM 활용 순서
    - 자바 컴파일러(javac)는 .java 파일을 .class라는 Java byte code로 변환
    - JVM은 OS가 Byte 코드를 이해할 수 있도록 해석
    - Byte 코드는 JVM 위에서 OS 상관없이 실행

- 컴파일 하는 방법 및 실행하는 방법
  - javac 는 자바 소스코드를 컴파일할 때 사용하는 프로그램이며 컴파일된 바이트 코드를 실행할 때 java 사용하여 실행
  - `$ javac 소스파일명.java`
  - `$ java 소스파일명`

- 컴파일 타임과 런타임
  - 런타임: 컴파일 과정을 마친 응용 프로그램이 사용자에 의해서 실행되는 때
  - 런타임 오류 : 0나누기 오류, 널(Null)참조 오류, 메모리 부족 오류
  - 컴파일타임: 소스코드가 컴파일러에 의해 컴퓨터가 이해할 수 있는 기계어 코드로 변환되는 때
  - 컴파일타임 오류: 신택스 오류, 타입체크 오류

- 바이트코드란 무엇인가
  - Byte 코드: 0과 1로 구성되어 있는 이진 코드이지만 일반적인 바이너리 코드와 다르게 가상 머신이 이해할 수 있는 바이너리 코드

- JIT 컴파일러란 무엇이며 어떻게 동작하는지
  - Java를 실행할 때 사용되는 컴파일러로 바이트코드를 읽어 기계어로 번역하지만 프로그램에는 반복적으로 사용하는 코드가 존재할 때 최초 1회만 번역하여 캐싱한 뒤 추가 참조가 필요할 때마다 불러와서 성능 향상시키는 기능을 가진 인터프리와 동시에 동작하는 컴파일러

- JVM 구성 요소
  - `Class Loader`
    - Runtime 시점에 .class에서 바이트 코드를 읽고 JVM의 메모리에 저장하는 요소
    - 로딩: 클래스를 읽어오는 과정
    - 링크: 레퍼런스를 연결하는 과정
    - 초기화: static 값들을 초기화 및 변수에 할당
  - `Runtime Data Areas`
    - JVM의 메모리 영역
    - Heap 과 Method는 모든 쓰레드가 공유하고 나머지는 쓰레드마다 생성
      - PC Register: CPU가 Instruction을 수행하는 동한 필요한 정보를 저장
      - Stack: Thread가 시작될 때 생성되며 Method와 Method 정보 저장
      - Navtive Method Stack: Java 이외의 언어로 작성된 native 코드를 위한 Stack
      - Method: 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수등의 바이트 코드 등을 보관)
      - Heap: 런타임시 동적으로 할당하여 사용하는 영역 class를 통해 instance를 생성하면 Heap에 저장됨
        - Heap의 경우 명시적으로 만든 class와 암묵적인 static 클래스(.class 파일의 class)가 담긴다.
        - 또한 암묵적인 static 클래스의 경우 클래스 로딩 시 class 타입의 인스턴스를 만들어 힙에 저장한다. 이는 Reflection에 등장한다.
  - `Execution Engine`
    - Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트 코드는 Execution Engine에 의해 실행
    - Load된 Class의 ByteCode를 실행하는 Runtime Module로 인터프리터, JIT 컴파일러, GC를 포함
  - `Native Method Interface(JNI)`
    - Java Native Interface(JNI)는 자바 가상 머신(JVM)위에서 실행되고 있는 자바코드가 네이티브 응용 프로그램 그리고 다른 언어들로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크

- JDK와 JRE의 차이
  - `JRE`: JRE는 자바 실행환경(Java Runtime Environment)의 약자로 JRE는 JVM 이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음
  - `JDK`: JDK는 자바 개발도구(Java Development Kit)의 약자로 JRE에 개발을 위해 필요한 도구(javac, java)를 포함

데이터 타입 변수 배열
=======
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값

  |타입|크기|범위|기본 값| 비고 |
  |---|---|---|----|-----|
  |byte| 1 byte|	-128 ~ 127	|0	|
  |short|	2 bytes|	-32,768 ~ 32,767	|0	|
  |(signed) int| 4 bytes|	-2^{31}  ~  2^{31}-1	|0	|
  |unsigned int| 4 bytes|	0  ~  2^{32}-1	|0|	java 8 이상부터 가능|
  |(signed) long|	8 bytes|	-2^{63}  ~  2^{63}-1	|0L|	
  |unsigned long|	8 bytes|	0  ~  2^{64}-1	|0L	|java 8 이상부터 가능|
  |float|	4 bytes|	single-precision 32-bit	|0.0f|	|
  |double| 8 bytes|	double-precision 64-bit	|0.0d|	|
  |boolean|	1 bit|	true / false	|false|	|
  |char| 2 bytes|	'\u0000' ~ '\uffff'	|'\u0000'|	|

- 프리미티브 타입과 레퍼런스 타입
  - **Primitive type**
    - byte, short, signed/unsigned int, signed/unsigned long, float, double, boolean, char
    - not object
    - 값 저장
    - 스택에 만들어짐
- **Reference type**
    - class, interface, enum, array, String type
    - 주소 저장
    - 힙에 만들어짐(가르키는 변수는 스택에 만들어짐)

- 리터럴
  - 리터럴은 변수나 상수에 저장되는 값 그 자체를 의미
  - 정수 리터럴
    - 정수 리터럴은 기본적으로 int 형이고, long 타입을 표현하려면 l이나 L을 마지막에 붙임
    - 기본적으로 10진법이고 0이 앞에 붙으면 8진법, 0x가 붙으면 16진법, 0b가 붙으면 2진법
    > 숫자가 매우 큰 경우는 리터럴 대신 BigInteger를 사용해야함
  - 실수 리터럴
    - 실수 리터널의 리터럴은 기본적으로 double 타입이고, float 타입으로 표현하려면 f를 명시적으로 붙임
    > 숫자가 매우 큰 경우는 리터럴 대신 BigDecimal를 사용해야함
  - 문자 리터럴
    - 문자는 작은따옴표(')안에 표현
  - 문자열 리터럴
    - 문자열은 큰따옴표(")안에 표현
  - boolean 리터럴
    - true, false 로 표현

- 변수 선언 및 초기화하는 방법
  - 변수 선언: 저장공간을 확보하겠다는 의미
  - 변수 초기화: 변수를 사용하기 전 처음으로 값을 저장하는 것

- 변수의 스코프와 라이프타임
  - `스코프`: 코프란 해당 변수를 사용할 수 있는 영역 범위
  - `라이프 타임`: 해당 변수가 메모리에 언제까지 살아있느지를 의미
  - 변수의 종류 

    |종류|의미|스코프|라이프타임| 비고 |
    |---|---|---|----|-----|
    |인스턴스 변수| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않은 변수|static method를 제외한 클래스 전체|클래스를 인스턴스화한 객체가 메모리에서 사라질 때 까지|
    |클래스 변수(전역변수)| 클래스 안에서 선언되어있고, 어떠한 메서드나 블럭 안에서 선언되지 않았으며 static 키워드가 포함되어 선언된 변수|클래스 전체|프로그램 종료시 까지|
    |지역 변수| 인스턴스 변수, 클래스 변수가 아닌 모든 변수|변수가 선언된 블럭 내부|변수가 선언된 블럭 내부에 있는 동안|

- 타입 변환, 캐스팅 그리고 타입 프로모션
  - 타입 변환: 변수나 리터럴의 타입을 다른 타입으로 변환하는 것
  - 타입 캐스팅: 타입캐스팅이란 크기가 더 큰 자료형을 크기가 더 작은 자료형에 대입하는 것, 데이터 손실이나 변형이 올 수 있음으로 명시적으로 `(자료형)`을 적어야함
  - 타입 프로모션: 기가 더 작은 자료형을 더 큰 자료형에 대입하는 것, 데이터 손실이나 변형이 오지 않음으로 캐스팅할 때 처럼 명시적으로 적지 않아도 자동으로 변환이 가능

- 배열 선언하기
  - 배열 선언: [] 혹은 변수명 뒤에 [] 붙여서 선언하고 new 연산이나 할당 연산을 통해서 초기화
  - 배열은 객체로 Runtime Stack 영역의 힙 영역 주소값을 가지고 값은 힙에 저장되는 방식
  ```java
  int [] arr; // 추천 방법
  int arr [];
  int arr2 [] = new int[10]; 
  int arr2 [][] = new int[10][10]; 
  int[] oneDimensionArrayEx1 = {1, 2, 3, 4, 5};
  int[][] twoDimensionArrayEx1 = {{1, 2}, {3, 4}};
  ```
- 타입 추론, var
  - 타입 추론: 데이터 타입을 소스코드에 명시하지 않아도, `컴파일 단계에서 컴파일러가 타입을 유추`해 정해주는 것
  - Java 5부터 추가된 Generic, Java 10부터 추가된 var가 타입 추론의 대표 기능
  - Generic(primitive type 사용 불가)
    - 제네릭 메소드: `<T> 반환형 매소드 이름(매개변수)` 방식으로 선언하여, 반환형과 매개변수의 데이터 타입을 함수를 호출할 때 결정
    - 제네릭 클래스: `class 클래스이름<T>` 방식으로 선언하여, 클래스 내부에서 사용하는 데이터의 타입을 클래스의 인스턴스를 생성할 때 결정
    > 자바의 모든 객체는 Object 상속하므로 다형성을 통해서 제네릭과 유사한 기능을 활용할 수있지만 형변환을 자주 해야하는 문제가 있음 
  - var
    - Local Variable Type Inference은 로컬 변수 선언을 var를 이용하여 기존의 엄격한 타입 선언방식에서 컴파일러에게 타입추론 책임을 위임하는 기능



연산자
=======
- 산술 연산자
  - 더하기: +는 기본적으로 두 수를 더하는 연산이지만 문자열을 연결시키는데도 사용, +의 피연산자 중 문자열이 있다면 다른 피연산자도 문자열로 변환
  - 빼기: - 연산자는 첫번째 피연산자에서 두번째 피연산자를 빼는 연산
  - 곱하기: * 연산자는 두 피연산자를 곱하는 연산
  - 나누기: / 연산자는 첫번째 피연산자를 두번째 피연산자로 나누는 연산
  - 나머지 연산: % 연산자는 첫번째 피연산자를 두번째 피연산자로 나누고 남은 나머지를 정수로 리턴하는 연산
  - 단항 마이너스 연산: 연산자를 단항 연산자로 사용하면 값의 부정이 수행되는 연산
- 비트 연산자: 비트 연산자(Bitwise Operators) 및 시프트 연산자(Shift Operators)는 개별 비트를 조작하는 저수준 연산자
  - `~`: 비트 반전 또는 비트 NOT 연산자로 각 비트를 반전시켜 1을 0으로, 0을 1로 변환
  - `&`: & 연산자는 두 정수 피연산자를 AND 연산(비트 곱)
  - `|`: | 연산자는 두 정수 피연산자를 OR 연산(비트 합)
  - `^`: ^ 연산자는 두 정수 피연산자를 XOR 연산, 비트가 같으면 0으로 다르면 1을 리턴
  - `<<`: << 연산자는 비트를 왼쪽으로 두번째 피연산자로 제시된 비트 수 만큼 이동, 기존의 가장 왼쪽 비트는 삭제되고 가장 오른쪽 비트는 0
  - `>>`: >> 연산자는 왼쪽 시프트 연산과 반대로 우측으로 두번째 피연산자로 제시된 비트 수 만큼 이동, 기존의 값이 양수인 경우 가장 왼쪽 비트는 0으로 채워지고 음수인 경우는 1

- 관계 연산자
  - `==`: == 연산자는 Primitive Type를 비교할 때 두 피연산자의 값이 같다면 true를 그렇지 않다면 false를 리턴 
  - `!=`: 두 피연산자의 값이 다른지 여부를 체크하여 true/false를 리턴
  - `<`: 첫번째 피연산자가 두번째 피연산자보다 작은지 여부를 리턴
  - `<=`: 첫번째 피연산자가 두번째 피연산자보다 작거나 같은지까지 여부를 리턴
  - `>`: 첫번째 피연산자가 두번째 피연산자보다 큰지 여부를 리턴
  - `>=`: 첫번째 피연산자가 두번째 피연산자보다 크거나 같은지까지 여부를 리턴

- 논리 연산자
  - `&&`: 두 피연산자가 모두 true인지 여부를 평가하며 두 피연산자 중 하나라도 false라면 false를 리턴
  - `||`: 두 피연산자 중 하나라도 true 라면 true를 리턴
  > 단락 회로 평가: &&와 || 연산을 사용할 때 첫 번째 피연산자의 결과에 따라 결과 값이 정해졌을 때 두 번째 피연산자의 평가를 하지 않는 것
  - `!`: 단항 연산자로 해당 값의 결과의 반대를 리턴

- instanceof
  - 객체(Object) 또는 배열(Array) 값을 어떠한 참조 유형에 맞는 값인지를 평가하는 연산자
  - null을 연산한다면 항상 false가 리턴
  ```java
  "Apple" instanceof String // true
  null instanceof String // false
  
  Object o = new int[]{1, 2, 3};
  o instanceof int[] // true
  ```
  > 일반적으로 instanceof를 사용하지 않는 것이 좋음

- 대입 연산자
  - 어떠한 변수에 값을 할당할 때 사용하는 연산자

- 화살표(->) 연산자
  - `->`: 람다 표현식(Lamda Expression) 이라고 하며 메소드 본문에 해당 실행 가능한 자바 코드의 익명 컬렉션
  > 함수형 프로그래밍은 간단히 말하자면 함수의 입력만을 의존해서 출력을 만드는 구조로 외부의 상태를 변경하는 것을 줄여 부작용 발생을 최소화 하는 방법론
  - 반환 타입과 메서드 이름 없이 `(Parameter 매개 변수) -> {Body 함수 몸체}` 형태로, 람다는 익명 함수의 매개변수와 리턴변수를 통해 만들어 짐
  ```java
  Runnable r = () -> {
    System.out.println("1");
    System.out.println("2");
  }

  // 코드가 한 문장이면 중괄호 생략 가능
  Runnable r = () -> System.out.println("1");
  ```

- 3항 연산자
  - `? :`: `조건 ? true일때 결과 : false 일때 결과`, if ~ else 문장을 연산자로 표현할 수 있고 조건에 따라 결과를 반환
  ```java
  public int max(int x, int y) {
    return x > y ? x : y;
  }
  ```

- 연산자 우선 순위

우선 순위 | 연산자 | 설명
| :---: | :---: | :---: |
1 | expr++ expr-- | 후위 증가/감소 연산자
2 | ++expr --expr +expr -expr ~ ! | 전위 증가/감소 연산자, 양/음 부호, 논리/비트 NOT 연산자
3 |	* ㅤ / ㅤ %	 | 곱셈/나눗셈/나머지 연산자
4 |	+ ㅤ -	 | 덧셈/뺄셈 연산자
5 |	<< ㅤ >> ㅤ >>>	 | 비트 왼쪽/오른쪽 Shift 연산자, Unsigned Shift 연산자
6 |	< ㅤ > ㅤ <= ㅤ >= ㅤ instanceof	 | 보다 작은/보다 큰/보다 작거나 같은/보다 크거나 같은 관계 연산자, instanceof
7 |	== ㅤ !=	| 와 같은/와 다른 관계 연산자
8 |	&	| 비트 AND 연산자
9 |	^	|비트 XOR 연산자
10 |	`|`	| 비트 OR 연산자
11 |	&&	| 논리 AND 연산자
12 |	`||`	| 논리 OR 연산자
13 |	? :	| 삼항 조건 연산자
14 |	= ㅤ += ㅤ -= ㅤ *= ㅤ /= ㅤ %= ㅤ &= ㅤ ^= ㅤ `|=` ㅤ <<= ㅤ >>= ㅤ >>>=	| 대입 연산자 및 복합 대입 연산자

제어문
=======
- 선택문
  - switch 문: 값을 입력 받고 그 값의 경우로 분기하여 실행하는 키워드
  ```java
  switch(domain){
    	case 1:
        break;
	    case 2:
		    break;
		    .
		    .
		    .
	    default:
		    break;
  }
  ```
  - if 문: 조건을 판단하고 참이면 if 블럭을 실행하는 키워드
  ```java
  if (expression){
    	statement;
  }
  ```
  - if else 문: 조건을 판단하고 참이면 if 블럭을 실행하고 거짓이면 else 블럭을 실행하는 키워드
  ```java
  if (expression){
    statement;
  } else {
    statement2;
  }
  ```
  - if else if 문: 여러 조건을 판단하고 if, else if 블럭 중에 참이 있으면 실행하고 아니면 else 블럭을 실행하는 키워드
  ```java
  if (expression){
    statement;
  } else if (expression2){
	  statement2;
  } 
  .
	.
	.
  else {
	  statement10;
  }
  ```
- 반복문
  - while: 조건을 검사하고 참이면 반복하는 키워드
  ```java
  while (expression){
    statement;
  }
  ```
  - do while: 명령을 최소 1번은 수행하고 조건을 검사하고 참이면 반복하는 키워드
  ```java
  do {
    statement;
  }
  while (expression)
  ```
  - for: 반복할 횟수를 지정하여 반복하는 키워드
  ```java
  for (변수 초기화; expression; statement) {
    statement;
  }
  ```
  - for each: 반복 가능한 객체가 있을 때 반복할 횟수를 제어하여 반복하는 키워드
  ```java
  for (타입 변수명 : iterable 객체) {
    statement;
  }
  ```
- 제어문
  - break: 반복문 중 반복을 종료할 수 있는 키워드
  - continue: 반복문 중 특정 조건 하에서 명령문 실행을 skip할 수 있는 키워드

클래스
=======
- 클래스 정의하는 방법
  - 클래스: 클래스는 데이터 필드나 메소드의 모음
  - 객체: 클래스에 규정된 인스턴스로서, 변수 대신 실제 값을 가짐
  - 클래스 구성 멤버
    - `필드(Field)`
      - 객체의 데이터(상태)가 저장되는 곳
      - 생성자와 메소드 전체에서 사용되며 객체가 소멸되기 전까지 객체와 함께 존재
    - `생성자(Constructor)`
      - 객체 생성 시 초기화
      - 생성자는 메소드와 비슷하게 생겼지만 클래스 이름으로 되어있고 리턴 타입이 없음
      - 생성자를 실행시키지 않고 클래스로부터 객체를 만들 수 없음
      - 생성자가 생성되면 Heap Area에 객체가 생성되고 객체의 주소가 리턴
      - 리턴된 객체의 주소는 클래스 타입 변수에 저장되어 객체에 접근 할 때 이용
      - 아무것도 안해도 디폴트 생성자가 만들어짐
    - `메소드(Method)`
      - 객체의 동작에 해당하는 실행 블록
      - 메소드를 호출하게 되면 중괄호 블록에 있는 코드들이 일괄적으로 실행되고 필드 읽기, 수정, 객체간 협력 수단 등 다양한 기능을 수행하기 위해 사용
    - 접근 제어자
      - public: 누구나 접근 할 수 있도록 할 때 사용
      - protected: 같은 패키지 내 그리고 상속 받은 경우에만 사용
      - package private: `기본 접근 지시자`로 같은 패키지 내에 있을 때만 접근 가능
      - private: 해당 클래스 내에서만 접근 가능
    - 클래스 제어자
      - abstract: 추상 클래스를 선언하고자 할때 사용, 이 클래스는 구현이 끝나지 않은 추상적인 형태의 클래스이므로, 객체로 생성될 수 없음
      - final: 상속이 더이상 되지 않는 클래스를 의미
  - 클래스 정의
  ```java
  public class Car{

    // 필드
    int battery;
    String engine;

    // 생성자
    Car() {...} 

    // 메소드
    void run() {...}
    void stop() {...}
  }
  ```
  
- 객체 만드는 방법 (new 키워드 이해하기)
  - 객체 생성
  ```java
  new Car();

  Car car; // 메모리에 참조변수 car를 위한 공간 생성
  car = new Car(); //  인스턴스 생성 및 대입
  Car car = new Car();
  ```
  - nwe 키워드
    - new 연산자로 생성된 객체는 `메모리 힙 영역`에 생성되고 객체의 주소를 리턴하는데 이 주소를 참조 타입인 클래스 변수에 저장
- 메소드 정의하는 방법
  - 메소드 정의
  ```java
  public class Car{
    int battery;
    String engine;

  void charge(){
        System.out.println("no charge");   
  }

  // 매개변수의 수를 모를 경우
  void charge(int... values){
    // int[] values == int...values

    for(int i = 0; i < values.length; i++){
         System.out.println("charge  "+i);   
    }
  }
  ```
  - 메서드 오버라이딩: 만약 자식의 클래스에서 부모 클래스의 메소드를 다른 방식으로 사용 및 구현하는 것
  - 메서드 오버로딩: 같은 함수 이름을 가지고 있으나 매개변수, 리턴타입 등의 특징은 다른 여러의 메소드를 정의하는 것
- 생성자 정의하는 방법
  - 생성자 정의
  ```java
  public class Car {
        int speed;
        String color;
    
    Car(){
      color = getDefaultColor();
      speed =0;
    }
    Car(String color){}
    Car(int speed){}
    Car(String color, int speed){}
    
    String getDefaultColor(){
      return "blue";
    }
  }
  ```
  - 초기화 블록
    - 클래스 초기화 블록: 클래스 변수 초기화에 쓰임
    - 인스턴스 초기화 블록: 인스턴스 변수 초기화에 쓰임
  - 다양한 제어자
    - 접근 제어자(pirvate, public ...)
    - `static`: static이 붙은 변수와 메서드는 객체가 아닌 클래스에 속함
    - `final`: final이 클래스 앞에 붙으면 해당 클래스는 상속될 수 없고 변수 또는 메서드 앞에 붙으면 수정되거나 오버라이딩 될 수 없음
    - abstract: abstract이 클래스 앞에 붙으면 추상 클래스가 되어 객체 생성이 불가하고, 접근을 위해선 상속받아야함
    - transient: 변수 또는 메서드가 포함된 객체를 직렬화할 때 무시하게하게 하는 제어자
    - `synchronized`: 메서드는 한 번에 하나의 쓰레드에 의해서만 접근 가능하게 하는 제어자
    - volatile: 해당 변수의 조작에 CPU 캐시가 쓰이지 않고 항상 메인 메모리로부터 읽게하는 제어자
- this 키워드 이해하기
  - this: 메소드나 생성자에서 현재 객체를 가리키고 있는 특별한 키워드
  - 주로 생성자와 메소드의 매개변수 이름이 필드와 동일한 경우 필드를 명시하기 위해 사용
  - 생성자 내에서 다른 생성자를 호출할 때 클래스 이름 대신 this를 사용해야함
  - 빌더 패턴 등에서 유용하게 사용할 수 있는, 현재 인스턴스의 reference를 반환해줄 때 사용
상속
=======
- 자바 상속의 특징
  - 자바에서 최상위 계층 부모 클래스는 java.lang.Object
  - 자바는 다중 상속을 지원하지 않으므로 extends 뒤에는 하나의 부모 클래스만 올 수 있음
  - 상속을 받은 클래스는 부모의 클래스에 선언되어있는 public및 protected 로 선언돼어있는 모든 변수와 메소드를 내가 가진 것 처럼 사용
- super 키워드
  - super: 부모 클래스를 지징하는 키워드
  - super(): 부모 클래스의 생성자
  - super.함수이름(): 부모 클래스의 메소드 사용 
- 메소드 오버라이딩
  - 자식 클래스에서 부모 클래스에 있는 메소드와 동일하게 선언하는 것
  > 메소드 오버로딩: 같은 함수 이름을 가지고 있으나 매개변수, 리턴타입 등의 특징은 다른 여러의 메소드를 정의하는 것
  - 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경 못함
  - 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없음
- 추상 클래스
  - 추상 클래스는 클래스를 만들기 위한 일종의 설계도로 인스턴스를 생성할 수 없는 클래스
  - 반드시 하나 이상의 추상 메서드를 포함하고 있고, 생성자와 멤버 변수 그리고 일반 메서드를 가질 수 있음
- 인터페이스
  - 추상 클래스의 일종으로 추상화정도가 높아 일반 메서드나 멤버 변수를 가질 수 없고 오로지 추상 메소드나 상수만을 멤버로 가질 수 있는 클래스를 정의하는 키워드
  - 인터페이스의 모든 멤버 변수와 메소드는 public static final이어야 하며, 이를 생략할 수도 있음
  - 다중 상속이 가능
- final 키워드
  - final 키워드: 엔티티를 한 번만 할당하겠다는 의미의 키워드
  - final 변수: 생성자나 대입연산자를 이용해 한 번만 초기화가 가능한 변수
  - final 메소드: final 메소드는 오버라이드하거나 숨길 수 없음을 의미
  - final 클래스: 해당 클래스는 상속할 수 없음을 의미하여 상속 계층에서 마지막 클래스라는 의미
- Object 클래스
  - java.lang.Object 클래스는 모든 클래스의 최상위 클래스로 기본 함수를 제공
  - clone (native 메소드): Clonable한 객체만 사용 가능한 메소드로 객체를 깊은 복사하는 메소드, `Clonable 인터페이스`의 clone 이라는 메소드를 오버라이딩해야함
  - equals: 객체의 참조값이 같은지만 비교하는 메소드
  - getClass (native 메소드): 객체의 런타임에서의 클래스(타입)을 반환
  - hashcode (native 메소드): 객체에 해당하는 해쉬코드를 만들어 반환
  - toString: toString()은 이 객체를 stirng으로 표현하는 방법을 표현하는 메소드로 기본적으로 객체의 경우 hash값이 출력
  - wait (native 메소드): 스레드를 정지 상태로 바꾸는 메소드 
  - notify (native 메소드): 정지 상태에 있는 다른 스레드를 실행 상태로 바꾸는 메소드
  - notifyAll (native 메소드): 정지 상태의 모든 스레드의 실행을 재개하는 메소드

패키지
=======
- package 키워드
  - 패키지: 클래스와 인터페이스 등의 집합을 의미
    - 파일을 묶음으로써 효율적으로 관리할 수 있으며 이름 충돌 문제도 피할 수 있음
    - 패키지 선언은 `package 패키지명`
    - 어떤 클래스를 패키지에 추가하게 되면 클래스의 이름은 `패키지명.클래스명`
  - 이름 없는 패키지
    - 자바의 모든 클래스는 반드시 하나 이상의 패키지에 포함되어야하는데, 소스 파일에 어떤 패키지 선언도 없다면 기본적은으로 하나의 이름 없는 패키지에 모아서 컴파일
- import 키워드
  - import: 다른 패키지에 접근하기 위해 사용
  ```java
  package c.javapackage;
  
  import c.javapackage.sub.Sub;
  
  public cass Package {
    public static void main(String[] args) {
        Sub.subClassSaticMethod();
        System.out.println(Sub.CLASS_NAME);     
    }
  }
  ```
  - import static: 다른 패키지의 static 한 변수와 메소드에 접근할 때 사용
  ```java
  package c.javapackage;
  
  import static c.javapackage.sub.Sub.subClassStaticMethod;
  import static c.javapackage.sub.Sub.CLASS_NAME;
  
  public cass Package {
    public static void main(String[] args) {     
        subClassSaticMethod();
        System.out.println(CLASS_NAME);
    }
  }
  ```

- 클래스 패스
  - 클래스 패스: 클래스를 찾기 위한 경로로, JVM 프로그램을 실행할 때 읽을 클래스 파일을 찾는 기준이 되는 경로(루트 폴더)
  - 클래스 패스 지정하기
    - java runtime cp/-classpath 플래그 사용
    ```java
    java -cp 폴더위치 패키지명.클래스명;패키지명.클래스명;패키지명.클래스명;...
    ```
    ```java
    java -classpath 폴더위치 패키지명.클래스명;패키지명.클래스명;패키지명.클래스명;...
    ```
    - CLASSPATH 시스템 환경 변수 지정
    ```sh
    // 쉘 커맨드에서 설정
    CLASSPATH=클래스패스경로
    ```
    ```sh
    echo $CLASSPATH
    ```
- 접근지시자
  - public: 누구나 접근 할 수 있도록 할 때 사용
  - protected: 같은 패키지 내 그리고 상속 받은 경우에만 사용
  - package private: `기본 접근 지시자`로 같은 패키지 내에 있을 때만 접근 가능
  - private: 해당 클래스 내에서만 접근 가능

인터페이스
=======


예외처리
=======


멀티쓰레드
=======


Enum
=======


애노테이션
=======


IO
=======


제네릭
=======


랑다식
=======


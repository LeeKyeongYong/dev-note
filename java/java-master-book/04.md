# 4장 배열과 컬렉션 공략하기

## 배열로 여러 데이터 처리하기

##### 배열이란?
- 배열: `동일 타입`의 값을 여러 개 취급할 수 있는 기능
```java
int[] array = new int[10];
```

##### 배열 초기화하기
- 배열은 요소 수가 고정된 데이터 구조이므로 초기화할 때 크기를 지정해야함
- 배열을 초기화하는 방법
```java
int[] array1 = new int[10]; // 크기만 지정

int[] array2 = {1, 2, 3, 4, 5}; // 초기값을 지정

int[] array3 = new int[] {6, 7, 8, 9, 10}; // 초기값과 타입을 지정
```
- 각 상황 별로 사용하는 초기화 방법
  - 선언 시 내용이 정해져 있지 않음 -> new로 요소 수만을 지정
  - 선언 시 내용이 정해져 있음 -> 값의 리스트를 열거
  - 선인 후에 내용이 정해지거나 인수를 이용 -> new 선언을 붙여서 값의 리스트를 열거

##### 배열의 대입과 취득
- 배열의 각 요소의 값은 인덱스를 사용하여 대입하거나 취득
- 배열의 크기를 넘어선 인덱스를 지정하여 값을 취득하려고 하는 경우 ArrayIndexOutOfBoudnsException이 발생
- 배열의 인덱스는 0부터 시작하여 마지막 요소의 인데스는 `배열의 크기 - 1`
- 자바의 배열에서는 `-1` 같은 인덱스 지정을 하용하지 않음

##### 배열의 사이즈 변경하기
- 배열은 한번 작성하면 요소 수를 변경할 수 없으므로 배열의 요소 수를 변경하고 싶은 경우 새로운 배열을 작성하고 복사해야함
- `java.util.Arrays`의 copyOf 메서드를 배열을 복사하는 수단으로 사용할 수 있으나 보통 ArrayList 인터페이스를 사용하는 것이 바람직함
```java
int[] array = {1,2,3,4,5};
int[] newArray = Arrays.copyOf(array, array.length + 3);
```

##### Arrays 클래스를 이용하여 배열 조작하기
- 자바에는 배열의 정렬이나 검색 등 자주 사용하는 배열 처리를 정리한 `java.util.Arrays` 클래스가 있음
- 배열의 문자열 반환
  - `java.util.Arrays` 클래스의 toString을 사용
```java
int[] array = {1,2,3,4,5};
System.out.println(array);
System.out.println(Arrays.toString(array));
```
- 배열의 정렬
  - `java.util.Arrays` 클래스의 sort를 사용
```java
int[] array = {1,2,3,4,5};
Arrays.sort(array); // 기본 타입 -> 오름 차순
System.out.println(Arrays.toString(array));

Comparator<Integer> c = new Comparator<Integer> () {
  @Override
  public int compare(iNTEGER o1, Integer o2) {
    return 02.compareTo(o1); // 반환값이 0 이상이면 인수 1 -> 인수2로 정렬, 반환 값이 0 미만이면 인수2 -> 인수1로 정렬
  }
};

Arrays.sort(array, c); // 기본 타입 -> 내림 차순
System.out.println(Arrays.toString(array)); 
```
- 객체 배열의 정렬
  - Comparable 인터페이스를 상속하고 compareTo 메소드를 오버라이딩하면 Arrays 클래스에 Comparator를 지정하지 않아도 해당 오버라이딩 옵션을 통해서는 정렬이 가능하나 한 종류의 정렬밖에 할 수 없어서 Comparator를 지정하는 방식이 선호됨
```java
@Data // lombok
public class Student {
  private String name;
  private int score;
}
```
```java
Student[] students = {
  new Student("Ken", 100),
  new Student("Kenny", 90),
  new Student("Kim", 55),
};

Comparator<Student> c = new Comparator<Student> () {
  @Override
  public int compare(Student o1, Student o2){
    return Integer.compare(o2.getScore(), 01.getScore());
  }
}

Arrays.sort(students, c);
for (Student student, students){
  System.out.println(student.getName() + ":" + student.getScore());
}
```
- 배열의 검색
  - 정렬되지 않은 배병에서는 선형 검색을하여 검색
  - 정렬된 배열 안에서 원하는 번호를 찾을 때 `java.util.Arrays` 클래스의 binarySearch 메서드를 사용할 수 있음
```java
int[] array = {1,1,4,5,7,21};
int foundIndex = Arrays.binarySearch(array, 5); // 발견되지 않은 경우는 0보다 작은 값을 반환
```

##### 가변 길이 인수로 메서드 정의하기
- 인수의 타입 뒤에 `...`를 지정하면 메서드의 인수에 배열을 지정할 수 있음
```java
void log(String message, string ... args) {
  System.out.println(message);
  for (String arg : args) {
    System.out.println(arg);
  }
}
```

## 컬렉션 프레임워크로 여러 데이터 처리하기

##### 배열의 한계와 컬렉션의 특징
- 배열은 길이가 결정되어 있기 때문에 요소의 추가나 삭제가 어려워서 `컬렉션`이라는 구조를 사용
- 배열처럼 사용할 수 있는 List 인터페이스와 키와 값을 나누어 사용할 수 있은 Map 인터페이스가 대표적

##### 대표적인 컬렉션과 구분 기준

|명칭|개요|
|------|---|
|배열|복수의 요소를 취급하는 메커니즘, 간단하지만 유연성이 떨어짐|
|java.util.List|배열처럼 복수의 요소를 취급할 수 있으며 인덱스를 지정해서 값의 취득이나 설정을 함|
|java.util.Set|중복하는 경우는 등록하지 않으면서 중복이 없는 복수의 요소를 취급|
|java.util.Map|키와 값을 이용하여 요소를 취합할 수 있음|

- 배열과 같이 인덱스를 지정해서 값의 취득이나 설정을 하고 싶은 경우 -> List
- 요소에 값의 중복이 없는 경우, 검색/정렬을 고속으로 실시하고 싶은 경우 -> Set
- 키와 값을 나누어서 요소를 취급하는 경우 -> Map


## 배열과 비슷한 방법으로 여러 요소 처리하기 - List

##### 

## 키와 값의 조합으로 값 처리하기 - Map

#####

## 갑의 집합 처리하기 - Set

#####

## 그 외의 인터페이스

#####
